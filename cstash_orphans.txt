
--- Orphans for apps\kernel-server\src\runtime.rs ---
Context (Prev): pub agent_id: String, [NL] pub model: String, [NL] pub prompt: String,
Context (Next): pub input_data: serde_json::Value, [NL] pub parent_signature: Option<String>, [NL] pub cached_content_id: Option<String>,
Code Prefix:  pub user_directive: String,
Comment:      // Runtime task from operator
----------------------------------------
Context (Prev): runtime_states: DashMap<String, RuntimeState>, [NL] thought_signatures: DashMap<String, ThoughtSignatureStore>, [NL] dag_store: DashMap<String, DAG>,
Context (Next): http_client: reqwest::Client, [NL] pub redis_client: Option<redis::Client>, [NL] pub event_bus: broadcast::Sender<RuntimeEvent>,
Code Prefix:  cache_resources: DashMap<String, String>,
Comment:      // run_id -> cached_content_id
----------------------------------------
Context (Prev): None [NL] } [NL] };
Context (Next): RARORuntime { [NL] workflows: DashMap::new(), [NL] runtime_states: DashMap::new(),
Code Prefix:  let (tx, _) = broadcast::channel(100);
Comment:      // Buffer 100 events
----------------------------------------
Context (Prev): } [NL] } [NL] };
Context (Next): let can_run = { [NL] let dag = self.dag_store.get(&run_id).unwrap(); [NL] let deps = dag.get_dependencies(&agent_id);
Code Prefix:  
Comment:      // 4. Verify Dependencies
----------------------------------------
Context (Prev): } [NL] } [NL] };
Context (Next): let can_run = { [NL] let dag = self.dag_store.get(&run_id).unwrap(); [NL] let deps = dag.get_dependencies(&agent_id);
Code Prefix:  
Comment:      // The topo sort gives us order, but we must ensure parents are actually *completed*.
----------------------------------------
Context (Prev): deps.iter().all(|d| state.completed_agents.contains(d)) [NL] }; [NL] if !can_run {
Context (Next): tokio::time::sleep(std::time::Duration::from_millis(100)).await; [NL] continue; [NL] }
Code Prefix:  
Comment:      // If dependencies aren't met, but topological sort put us here,
----------------------------------------
Context (Prev): deps.iter().all(|d| state.completed_agents.contains(d)) [NL] }; [NL] if !can_run {
Context (Next): tokio::time::sleep(std::time::Duration::from_millis(100)).await; [NL] continue; [NL] }
Code Prefix:  
Comment:      // it means dependencies are still running or failed.
----------------------------------------
Context (Prev): deps.iter().all(|d| state.completed_agents.contains(d)) [NL] }; [NL] if !can_run {
Context (Next): tokio::time::sleep(std::time::Duration::from_millis(100)).await; [NL] continue; [NL] }
Code Prefix:  
Comment:      // We wait.
----------------------------------------
Context (Prev): let state = self.runtime_states.get(run_id).ok_or("Run not found")?; [NL] let workflow_id = state.workflow_id.clone(); [NL] drop(state); // Drop read lock
Context (Next): let existing_dependents: Vec<String> = if let Some(dag) = self.dag_store.get(run_id) { [NL] let existing_nodes = dag.export_nodes(); [NL] for node in &mut req.new_nodes {
Code Prefix:  
Comment:      // 2. PRE-FETCH DEPENDENTS & SANITIZE IDs
----------------------------------------
Context (Prev): let workflow_id = state.workflow_id.clone(); [NL] drop(state); // Drop read lock [NL] let existing_dependents: Vec<String> = if let Some(dag) = self.dag_store.get(run_id) {
Context (Next): let existing_nodes = dag.export_nodes(); [NL] for node in &mut req.new_nodes { [NL] if existing_nodes.contains(&node.id) {
Code Prefix:  
Comment:      // A. Sanitize IDs to prevent cycles
----------------------------------------
Context (Prev): node.id = new_id; [NL] } [NL] }
Context (Next): dag.get_children(parent_id) [NL] } else { [NL] return Err("DAG not found for pre-fetch".to_string());
Code Prefix:  
Comment:      // B. Get children
----------------------------------------
Context (Prev): } else { [NL] return Err("DAG not found for pre-fetch".to_string()); [NL] };
Context (Next): if let Some(mut workflow) = self.workflows.get_mut(&workflow_id) { [NL] for node in &req.new_nodes { [NL] workflow.agents.push(node.clone());
Code Prefix:  
Comment:      // 3. MUTATE WORKFLOW CONFIG (CRITICAL STEP FOR CONTEXT)
----------------------------------------
Context (Prev): return Err("Workflow config not found".to_string()); [NL] } [NL] if let Some(mut dag) = self.dag_store.get_mut(run_id) {
Context (Next): for node in &req.new_nodes { [NL] dag.add_node(node.id.clone()).map_err(|e| e.to_string())?; [NL] dag.add_edge(parent_id.to_string(), node.id.clone()).map_err(|e| e.to_string())?;
Code Prefix:  
Comment:      // A. Add New Nodes & Edges from Parent
----------------------------------------
Context (Prev): if let Some(mut dag) = self.dag_store.get_mut(run_id) { [NL] for node in &req.new_nodes { [NL] dag.add_node(node.id.clone()).map_err(|e| e.to_string())?;
Context (Next): dag.add_edge(parent_id.to_string(), node.id.clone()).map_err(|e| e.to_string())?; [NL] if req.strategy == DelegationStrategy::Child { [NL] for dep in &existing_dependents {
Code Prefix:  
Comment:      // Parent -> New Node
----------------------------------------
Context (Prev): ModelVariant::Thinking => "thinking".to_string(), [NL] ModelVariant::Custom(s) => s.clone(), [NL] };
Context (Next): let thinking_level = if matches!(agent_config.model, ModelVariant::Thinking) { [NL] Some(5) // Default budget level for Thinking models [NL] } else {
Code Prefix:  
Comment:      // 9. Configure Thinking Budget
----------------------------------------

--- Orphans for apps\kernel-server\src\runtime.rs ---
Type: block
Prev Context: !state.active_agents.contains(agent_id) [NL] }) [NL] };
Next Context: let agent_id = match next_agent_opt { [NL] Some(id) => id, [NL] None => {
Text:         // 3. If no next agent, check if we are done...
----------------------------------------
Type: block
Prev Context: } [NL] } [NL] };
Next Context: let can_run = { [NL] let dag = self.dag_store.get(&run_id).unwrap(); [NL] let deps = dag.get_dependencies(&agent_id);
Text:         // 4. Verify Dependencies
// The topo sort gives u...
----------------------------------------
Type: block
Prev Context: deps.iter().all(|d| state.completed_agents.contains(d)) [NL] }; [NL] if !can_run {
Next Context: tokio::time::sleep(std::time::Duration::from_millis(100)).await; [NL] continue; [NL] }
Text:         // If dependencies aren't met, but topological sor...
----------------------------------------
Type: block
Prev Context: tokio::time::sleep(std::time::Duration::from_millis(100)).await; [NL] continue; [NL] }
Next Context: tracing::info!("Processing agent: {}", agent_id); [NL] self.update_agent_status(&run_id, &agent_id, InvocationStatus::Running).await; [NL] self.emit_event(RuntimeEvent::new(
Text:         // 5. Execute Agent...
----------------------------------------
Type: block
Prev Context: } else { [NL] false [NL] };
Next Context: if !can_delegate { [NL] tracing::warn!("Agent {} attempted delegation without permission. Ignoring.", agent_id); [NL] } else {
Text:         // 2. Execute Mutation (Acquire Write Lock inside ...
----------------------------------------
Type: block
Prev Context: node.id = new_id; [NL] } [NL] }
Next Context: dag.get_children(parent_id) [NL] } else { [NL] return Err("DAG not found for pre-fetch".to_string());
Text:         // B. Get children...
----------------------------------------
Type: block
Prev Context: } else { [NL] return Err("DAG not found for pre-fetch".to_string()); [NL] };
Next Context: if let Some(mut workflow) = self.workflows.get_mut(&workflow_id) { [NL] for node in &req.new_nodes { [NL] workflow.agents.push(node.clone());
Text:         // 3. MUTATE WORKFLOW CONFIG (CRITICAL STEP FOR CO...
----------------------------------------
Type: block
Prev Context: return Err("DAG not found for pre-fetch".to_string()); [NL] }; [NL] if let Some(mut workflow) = self.workflows.get_mut(&workflow_id) {
Next Context: for node in &req.new_nodes { [NL] workflow.agents.push(node.clone()); [NL] }
Text:         // A. Register new agents...
----------------------------------------
Type: block
Prev Context: return Err("Workflow config not found".to_string()); [NL] } [NL] if let Some(mut dag) = self.dag_store.get_mut(run_id) {
Next Context: for node in &req.new_nodes { [NL] dag.add_node(node.id.clone()).map_err(|e| e.to_string())?; [NL] dag.add_edge(parent_id.to_string(), node.id.clone()).map_err(|e| e.to_string())?;
Text:         // A. Add New Nodes & Edges from Parent...
----------------------------------------
Type: block
Prev Context: if let Some(dag) = self.dag_store.get(run_id) { [NL] let edges = dag.export_edges(); [NL] let nodes = dag.export_nodes();
Next Context: Some(serde_json::json!({ [NL] "nodes": nodes, [NL] "edges": edges.into_iter().map(|(from, to)| {
Text:         // Convert to the JSON structure the frontend expe...
----------------------------------------

--- Orphans for apps\kernel-server\src\runtime.rs ---
Type: block
Prev Context: } [NL] } [NL] };
Next Context: let can_run = { [NL] let dag = self.dag_store.get(&run_id).unwrap(); [NL] let deps = dag.get_dependencies(&agent_id);
Text:         // 4. Verify Dependencies
// The topo sort gives u...
----------------------------------------
Type: block
Prev Context: deps.iter().all(|d| state.completed_agents.contains(d)) [NL] }; [NL] if !can_run {
Next Context: tokio::time::sleep(std::time::Duration::from_millis(100)).await; [NL] continue; [NL] }
Text:         // If dependencies aren't met, but topological sor...
----------------------------------------
Type: block
Prev Context: tokio::time::sleep(std::time::Duration::from_millis(100)).await; [NL] continue; [NL] }
Next Context: tracing::info!("Processing agent: {}", agent_id); [NL] self.update_agent_status(&run_id, &agent_id, InvocationStatus::Running).await; [NL] self.emit_event(RuntimeEvent::new(
Text:         // 5. Execute Agent...
----------------------------------------
Type: block
Prev Context: } else { [NL] false [NL] };
Next Context: if !can_delegate { [NL] tracing::warn!("Agent {} attempted delegation without permission. Ignoring.", agent_id); [NL] } else {
Text:         // 2. Execute Mutation (Acquire Write Lock inside ...
----------------------------------------
Type: block
Prev Context: if !can_delegate { [NL] tracing::warn!("Agent {} attempted delegation without permission. Ignoring.", agent_id); [NL] } else {
Next Context: match self.handle_delegation(&run_id, &agent_id, delegation).await { [NL] Ok(_) => { [NL] tracing::info!("Delegation processed. Graph updated.");
Text:         // Agent has permission - process delegation...
----------------------------------------
Type: block
Prev Context: } [NL] } [NL] }
Next Context: if let Some(sig) = res.thought_signature { [NL] let _ = self.set_thought_signature(&run_id, &agent_id, sig); [NL] }
Text:         // B. Standard Completion Logic...
----------------------------------------
Type: block
Prev Context: if let Some(sig) = res.thought_signature { [NL] let _ = self.set_thought_signature(&run_id, &agent_id, sig); [NL] }
Next Context: let artifact_id = if let Some(output_data) = &res.output { [NL] if let Some(files_array) = output_data.get("files_generated").and_then(|v| v.as_array()) { [NL] let workflow_id = self.runtime_states.get(&run_id)
Text:         // Store Artifact...
----------------------------------------
Type: block
Prev Context: let _ = self.set_thought_signature(&run_id, &agent_id, sig); [NL] } [NL] let artifact_id = if let Some(output_data) = &res.output {
Next Context: if let Some(files_array) = output_data.get("files_generated").and_then(|v| v.as_array()) { [NL] let workflow_id = self.runtime_states.get(&run_id) [NL] .map(|s| s.workflow_id.clone())
Text:         // === AUTO-PROMOTE ARTIFACTS TO PERSISTENT STORAG...
----------------------------------------
Type: block
Prev Context: } [NL] let artifact_id = if let Some(output_data) = &res.output { [NL] if let Some(files_array) = output_data.get("files_generated").and_then(|v| v.as_array()) {
Next Context: let workflow_id = self.runtime_states.get(&run_id) [NL] .map(|s| s.workflow_id.clone()) [NL] .unwrap_or_default();
Text:         // Extract workflow_id from runtime state...
----------------------------------------
Type: block
Prev Context: let workflow_id = self.runtime_states.get(&run_id) [NL] .map(|s| s.workflow_id.clone()) [NL] .unwrap_or_default();
Next Context: let user_directive = { [NL] if let Some(workflow) = self.workflows.get(&workflow_id) { [NL] workflow.agents.iter()
Text:         // Extract user_directive by cloning the workflow ...
----------------------------------------
Type: block
Prev Context: let aid = agent_id.clone(); [NL] let fname = filename.to_string(); [NL] let directive = user_directive.clone();
Next Context: tokio::spawn(async move { [NL] match fs_manager::WorkspaceInitializer::promote_artifact_to_storage( [NL] &rid, &wid, &aid, &fname, &directive
Text:         // Fire-and-forget promotion (don't block executio...
----------------------------------------
Type: block
Prev Context: } [NL] } [NL] }
Next Context: let agent_stored_flag = output_data.get("artifact_stored") [NL] .and_then(|v| v.as_bool()) [NL] .unwrap_or(false);
Text:         // ============================================...
----------------------------------------
Type: block
Prev Context: self.store_artifact(&run_id, &agent_id, output_data).await [NL] } [NL] } else { None };
Next Context: let invocation = AgentInvocation { [NL] id: Uuid::new_v4().to_string(), [NL] agent_id: agent_id.clone(),
Text:         // Record Metrics...
----------------------------------------
Type: block
Prev Context: error_message: None, [NL] }; [NL] let _ = self.record_invocation(&run_id, invocation).await;
Next Context: self.emit_event(RuntimeEvent::new( [NL] &run_id, [NL] EventType::AgentCompleted,
Text:         // Emit AgentCompleted event...
----------------------------------------
Type: block
Prev Context: serde_json::json!({"agent_id": agent_id, "tokens_used": res.tokens_used}), [NL] )); [NL] } else {
Next Context: let error = res.error.unwrap_or_else(|| "Unknown error".to_string()); [NL] self.emit_event(RuntimeEvent::new( [NL] &run_id,
Text:         // Failure...
----------------------------------------
Type: block
Prev Context: )); [NL] } else { [NL] let error = res.error.unwrap_or_else(|| "Unknown error".to_string());
Next Context: self.emit_event(RuntimeEvent::new( [NL] &run_id, [NL] EventType::AgentFailed,
Text:         // Emit AgentFailed event...
----------------------------------------
Type: block
Prev Context: } [NL] } [NL] Err(e) => {
Next Context: self.emit_event(RuntimeEvent::new( [NL] &run_id, [NL] EventType::AgentFailed,
Text:         // Emit AgentFailed event for network errors...
----------------------------------------
Type: block
Prev Context: } [NL] } [NL] }
Next Context: async fn handle_delegation(&self, run_id: &str, parent_id: &str, mut req: DelegationRequest) -> Result<(), String> { [NL] let state = self.runtime_states.get(run_id).ok_or("Run not found")?; [NL] let workflow_id = state.workflow_id.clone();
Text:         /// Handles the "Graph Surgery" when an agent requ...
----------------------------------------
Type: block
Prev Context: } [NL] } [NL] async fn handle_delegation(&self, run_id: &str, parent_id: &str, mut req: DelegationRequest) -> Result<(), String> {
Next Context: let state = self.runtime_states.get(run_id).ok_or("Run not found")?; [NL] let workflow_id = state.workflow_id.clone(); [NL] drop(state); // Drop read lock
Text:         // 1. Get State to identify Workflow ID...
----------------------------------------
Type: block
Prev Context: let state = self.runtime_states.get(run_id).ok_or("Run not found")?; [NL] let workflow_id = state.workflow_id.clone(); [NL] drop(state); // Drop read lock
Next Context: let existing_dependents: Vec<String> = if let Some(dag) = self.dag_store.get(run_id) { [NL] let existing_nodes = dag.export_nodes(); [NL] for node in &mut req.new_nodes {
Text:         // 2. PRE-FETCH DEPENDENTS & SANITIZE IDs...
----------------------------------------
Type: block
Prev Context: let workflow_id = state.workflow_id.clone(); [NL] drop(state); // Drop read lock [NL] let existing_dependents: Vec<String> = if let Some(dag) = self.dag_store.get(run_id) {
Next Context: let existing_nodes = dag.export_nodes(); [NL] for node in &mut req.new_nodes { [NL] if existing_nodes.contains(&node.id) {
Text:         // A. Sanitize IDs to prevent cycles...
----------------------------------------
Type: block
Prev Context: node.id = new_id; [NL] } [NL] }
Next Context: dag.get_children(parent_id) [NL] } else { [NL] return Err("DAG not found for pre-fetch".to_string());
Text:         // B. Get children...
----------------------------------------
Type: block
Prev Context: } else { [NL] return Err("DAG not found for pre-fetch".to_string()); [NL] };
Next Context: if let Some(mut workflow) = self.workflows.get_mut(&workflow_id) { [NL] for node in &req.new_nodes { [NL] workflow.agents.push(node.clone());
Text:         // 3. MUTATE WORKFLOW CONFIG (CRITICAL STEP FOR CO...
----------------------------------------
Type: block
Prev Context: return Err("DAG not found for pre-fetch".to_string()); [NL] }; [NL] if let Some(mut workflow) = self.workflows.get_mut(&workflow_id) {
Next Context: for node in &req.new_nodes { [NL] workflow.agents.push(node.clone()); [NL] }
Text:         // A. Register new agents...
----------------------------------------
Type: block
Prev Context: for node in &req.new_nodes { [NL] workflow.agents.push(node.clone()); [NL] }
Next Context: if req.strategy == DelegationStrategy::Child { [NL] for dep_id in &existing_dependents { [NL] if let Some(dep_agent) = workflow.agents.iter_mut().find(|a| a.id == *dep_id) {
Text:         // B. Rewire Configuration Dependencies...
----------------------------------------
Type: block
Prev Context: } else { [NL] return Err("Workflow config not found".to_string()); [NL] }
Next Context: if let Some(mut dag) = self.dag_store.get_mut(run_id) { [NL] for node in &req.new_nodes { [NL] dag.add_node(node.id.clone()).map_err(|e| e.to_string())?;
Text:         // 4. MUTATE DAG TOPOLOGY (EXECUTION ORDER)...
----------------------------------------
Type: block
Prev Context: return Err("Workflow config not found".to_string()); [NL] } [NL] if let Some(mut dag) = self.dag_store.get_mut(run_id) {
Next Context: for node in &req.new_nodes { [NL] dag.add_node(node.id.clone()).map_err(|e| e.to_string())?; [NL] dag.add_edge(parent_id.to_string(), node.id.clone()).map_err(|e| e.to_string())?;
Text:         // A. Add New Nodes & Edges from Parent...
----------------------------------------
Type: block
Prev Context: if let Some(mut dag) = self.dag_store.get_mut(run_id) { [NL] for node in &req.new_nodes { [NL] dag.add_node(node.id.clone()).map_err(|e| e.to_string())?;
Next Context: dag.add_edge(parent_id.to_string(), node.id.clone()).map_err(|e| e.to_string())?; [NL] if req.strategy == DelegationStrategy::Child { [NL] for dep in &existing_dependents {
Text:         // Parent -> New Node...
----------------------------------------
Type: block
Prev Context: for node in &req.new_nodes { [NL] dag.add_node(node.id.clone()).map_err(|e| e.to_string())?; [NL] dag.add_edge(parent_id.to_string(), node.id.clone()).map_err(|e| e.to_string())?;
Next Context: if req.strategy == DelegationStrategy::Child { [NL] for dep in &existing_dependents { [NL] dag.add_edge(node.id.clone(), dep.clone()).map_err(|e| e.to_string())?;
Text:         // B. Connect New Nodes -> Existing Dependents...
----------------------------------------
Type: block
Prev Context: None => return "Graph topology unavailable.".to_string(), [NL] }; [NL] if detailed {
Next Context: let nodes: Vec<serde_json::Value> = dag.export_nodes().iter().map(|node_id| { [NL] let status = if state.completed_agents.contains(node_id) { "completed" } [NL] else if state.failed_agents.contains(node_id) { "failed" }
Text:         // DETAILED VIEW: JSON topology for orchestrators
...
----------------------------------------
Type: block
Prev Context: }).collect(); [NL] return serde_json::to_string_pretty(&nodes).unwrap_or_default(); [NL] } else {
Next Context: match dag.topological_sort() { [NL] Ok(order) => { [NL] let parts: Vec<String> = order.iter().map(|node_id| {
Text:         // LINEAR VIEW: High-level progress indicator for ...
----------------------------------------
Type: block
Prev Context: } [NL] } [NL] }
Next Context: pub async fn prepare_invocation_payload( [NL] &self, [NL] run_id: &str,
Text:         /// Prepare invocation payload with signature rout...
----------------------------------------
Type: block
Prev Context: run_id: &str, [NL] agent_id: &str, [NL] ) -> Result<InvocationPayload, String> {
Next Context: let state = self [NL] .runtime_states [NL] .get(run_id)
Text:         // 1. Retrieve Runtime State...
----------------------------------------
Type: block
Prev Context: .runtime_states [NL] .get(run_id) [NL] .ok_or_else(|| "Run not found".to_string())?;
Next Context: let workflow = self [NL] .workflows [NL] .get(&state.workflow_id)
Text:         // 2. Retrieve Workflow Configuration...
----------------------------------------
Type: block
Prev Context: .workflows [NL] .get(&state.workflow_id) [NL] .ok_or_else(|| "Workflow not found".to_string())?;
Next Context: let agent_config = workflow [NL] .agents [NL] .iter()
Text:         // 3. Find Specific Agent Config...
----------------------------------------
Type: block
Prev Context: .iter() [NL] .find(|a| a.id == agent_id) [NL] .ok_or_else(|| format!("Agent {} not found", agent_id))?;
Next Context: let parent_signature = if !agent_config.depends_on.is_empty() { [NL] agent_config [NL] .depends_on
Text:         // 4. Fetch Parent Signatures (Chain of Thought Co...
----------------------------------------
Type: block
Prev Context: } else { [NL] None [NL] };
Next Context: let mut context_prompt_appendix = String::new(); [NL] let mut input_data_map = serde_json::Map::new(); [NL] let mut dynamic_file_mounts: Vec<String> = Vec::new();
Text:         // 5. Context & Artifact Retrieval (Redis)...
----------------------------------------
Type: block
Prev Context: let mut dynamic_file_mounts: Vec<String> = Vec::new(); [NL] if !agent_config.depends_on.is_empty() { [NL] if let Some(client) = &self.redis_client {
Next Context: match client.get_async_connection().await { [NL] Ok(mut con) => { [NL] for parent_id in &agent_config.depends_on {
Text:         // Use a separate async connection to avoid borrow...
----------------------------------------
Type: block
Prev Context: Ok(mut con) => { [NL] for parent_id in &agent_config.depends_on { [NL] let key = format!("run:{}:agent:{}:output", run_id, parent_id);
Next Context: let data: Option<String> = con.get(&key).await.unwrap_or(None); [NL] if let Some(json_str) = data { [NL] if let Ok(val) = serde_json::from_str::<serde_json::Value>(&json_str) {
Text:         // Attempt to fetch artifact from Redis...
----------------------------------------
Type: block
Prev Context: let data: Option<String> = con.get(&key).await.unwrap_or(None); [NL] if let Some(json_str) = data { [NL] if let Ok(val) = serde_json::from_str::<serde_json::Value>(&json_str) {
Next Context: input_data_map.insert(parent_id.clone(), val.clone()); [NL] let content = val.get("result") [NL] .and_then(|v| v.as_str())
Text:         // A. Structured Input Data...
----------------------------------------
Type: block
Prev Context: if let Some(json_str) = data { [NL] if let Ok(val) = serde_json::from_str::<serde_json::Value>(&json_str) { [NL] input_data_map.insert(parent_id.clone(), val.clone());
Next Context: let content = val.get("result") [NL] .and_then(|v| v.as_str()) [NL] .or_else(|| val.get("output").and_then(|v| v.as_str()))
Text:         // B. Text Context (The "Result" string)...
----------------------------------------
Type: block
Prev Context: .or_else(|| val.get("output").and_then(|v| v.as_str())) [NL] .unwrap_or("No text output"); [NL] context_prompt_appendix.push_str(&format!("\n\n=== CONTEXT FROM AGENT {} ===\n{}\n", parent_id, content));
Next Context: if let Some(files_array) = val.get("files_generated").and_then(|v| v.as_array()) { [NL] for file_val in files_array { [NL] if let Some(filename) = file_val.as_str() {
Text:         // C. Dynamic File Mounting (Manifest Pattern)
// ...
----------------------------------------
Type: block
Prev Context: if let Some(files_array) = val.get("files_generated").and_then(|v| v.as_array()) { [NL] for file_val in files_array { [NL] if let Some(filename) = file_val.as_str() {
Next Context: let mount_path = format!("/app/storage/sessions/{}/output/{}", run_id, filename); [NL] if !dynamic_file_mounts.contains(&mount_path) { [NL] dynamic_file_mounts.push(mount_path);
Text:         // Construct absolute path to the RFS session outp...
----------------------------------------
Type: block
Prev Context: for file_val in files_array { [NL] if let Some(filename) = file_val.as_str() { [NL] let mount_path = format!("/app/storage/sessions/{}/output/{}", run_id, filename);
Next Context: if !dynamic_file_mounts.contains(&mount_path) { [NL] dynamic_file_mounts.push(mount_path); [NL] }
Text:         // Deduplication: Only add if not already in the l...
----------------------------------------
Type: block
Prev Context: tracing::warn!("Redis client unavailable. Context fetching skipped."); [NL] } [NL] }
Next Context: let mut final_prompt = agent_config.prompt.clone(); [NL] if !context_prompt_appendix.is_empty() { [NL] final_prompt.push_str(&context_prompt_appendix);
Text:         // 6. Construct Final Prompt...
----------------------------------------
Type: block
Prev Context: if !context_prompt_appendix.is_empty() { [NL] final_prompt.push_str(&context_prompt_appendix); [NL] }
Next Context: let cached_content_id = self.get_cache_resource(run_id); [NL] let model_string = match &agent_config.model { [NL] ModelVariant::Fast => "fast".to_string(),
Text:         // 7. Get Cached Content ID (if applicable)...
----------------------------------------
Type: block
Prev Context: final_prompt.push_str(&context_prompt_appendix); [NL] } [NL] let cached_content_id = self.get_cache_resource(run_id);
Next Context: let model_string = match &agent_config.model { [NL] ModelVariant::Fast => "fast".to_string(), [NL] ModelVariant::Reasoning => "reasoning".to_string(),
Text:         // 8. Determine Model Variant String...
----------------------------------------
Type: block
Prev Context: ModelVariant::Thinking => "thinking".to_string(), [NL] ModelVariant::Custom(s) => s.clone(), [NL] };
Next Context: let thinking_level = if matches!(agent_config.model, ModelVariant::Thinking) { [NL] Some(5) // Default budget level for Thinking models [NL] } else {
Text:         // 9. Configure Thinking Budget...
----------------------------------------
Type: block
Prev Context: } else { [NL] None [NL] };
Next Context: let mut full_file_paths: Vec<String> = workflow.attached_files.iter() [NL] .map(|f| format!("/app/storage/sessions/{}/input/{}", run_id, f)) [NL] .collect();
Text:         // 10. Construct File Paths List
// Start with fil...
----------------------------------------
Type: block
Prev Context: let mut full_file_paths: Vec<String> = workflow.attached_files.iter() [NL] .map(|f| format!("/app/storage/sessions/{}/input/{}", run_id, f)) [NL] .collect();
Next Context: let has_dynamic_artifacts = !dynamic_file_mounts.is_empty(); [NL] let dynamic_artifact_count = dynamic_file_mounts.len(); [NL] if has_dynamic_artifacts {
Text:         // Track if we have dynamic artifacts (before movi...
----------------------------------------
Type: block
Prev Context: .collect(); [NL] let has_dynamic_artifacts = !dynamic_file_mounts.is_empty(); [NL] let dynamic_artifact_count = dynamic_file_mounts.len();
Next Context: if has_dynamic_artifacts { [NL] tracing::info!("Mounting {} dynamic artifacts for agent {}", dynamic_artifact_count, agent_id); [NL] full_file_paths.extend(dynamic_file_mounts);
Text:         // Append files generated by parent agents (Output...
----------------------------------------
Type: block
Prev Context: tracing::info!("Mounting {} dynamic artifacts for agent {}", dynamic_artifact_count, agent_id); [NL] full_file_paths.extend(dynamic_file_mounts); [NL] }
Next Context: let mut tools = agent_config.tools.clone(); [NL] let baseline_tools = vec!["read_file", "list_files", "write_file"]; [NL] for baseline in baseline_tools {
Text:         // 11. SMART TOOL ACCESS (Prevents UNEXPECTED_TOOL...
----------------------------------------
Type: block
Prev Context: full_file_paths.extend(dynamic_file_mounts); [NL] } [NL] let mut tools = agent_config.tools.clone();
Next Context: let baseline_tools = vec!["read_file", "list_files", "write_file"]; [NL] for baseline in baseline_tools { [NL] if !tools.contains(&baseline.to_string()) {
Text:         // Baseline tools that ALL agents should have acce...
----------------------------------------
Type: block
Prev Context: tracing::debug!("Agent {}: Added baseline tool '{}'", agent_id, baseline); [NL] } [NL] }
Next Context: if has_dynamic_artifacts && !tools.contains(&"execute_python".to_string()) { [NL] tools.push("execute_python".to_string()); [NL] tracing::info!(
Text:         // Smart Enhancement: If agent receives files from...
----------------------------------------
Type: block
Prev Context: dynamic_artifact_count [NL] ); [NL] }
Next Context: if tools.contains(&"write_file".to_string()) && !tools.contains(&"execute_python".to_string()) { [NL] tools.push("execute_python".to_string()); [NL] tracing::debug!("Agent {}: Added 'execute_python' (has write_file capability)", agent_id);
Text:         // Smart Enhancement: If agent has write_file, it ...
----------------------------------------
Type: block
Prev Context: tools.push("execute_python".to_string()); [NL] tracing::debug!("Agent {}: Added 'execute_python' (has write_file capability)", agent_id); [NL] }
Next Context: let graph_view = self.generate_graph_context( [NL] run_id, [NL] agent_id,
Text:         // 11. Generate Graph Context (NEW)
// Give orches...
----------------------------------------
Type: block
Prev Context: agent_id, [NL] agent_config.allow_delegation [NL] );
Next Context: Ok(InvocationPayload { [NL] run_id: run_id.to_string(), [NL] agent_id: agent_id.to_string(),
Text:         // 12. Return Payload...
----------------------------------------
Type: block
Prev Context: thinking_level, [NL] file_paths: full_file_paths, [NL] tools, // Now contains Architect's choices + smart baseline guarantees
Next Context: allow_delegation: agent_config.allow_delegation, [NL] graph_view, [NL] })
Text:         // [[NEW FIELDS]]...
----------------------------------------
Type: block
Prev Context: pub fn set_run_status(&self, run_id: &str, status: RuntimeStatus) { [NL] if let Some(mut state) = self.runtime_states.get_mut(run_id) { [NL] state.status = status;
Next Context: } [NL] } [NL] pub fn get_topology_snapshot(&self, run_id: &str) -> Option<serde_json::Value> {
Text:         // Trigger async persistence here...
----------------------------------------
Type: block
Prev Context: state.status = status; [NL] } [NL] }
Next Context: pub fn get_topology_snapshot(&self, run_id: &str) -> Option<serde_json::Value> { [NL] if let Some(dag) = self.dag_store.get(run_id) { [NL] let edges = dag.export_edges();
Text:         /// Returns the current topology (nodes and edges)...
----------------------------------------
Type: block
Prev Context: if let Some(dag) = self.dag_store.get(run_id) { [NL] let edges = dag.export_edges(); [NL] let nodes = dag.export_nodes();
Next Context: Some(serde_json::json!({ [NL] "nodes": nodes, [NL] "edges": edges.into_iter().map(|(from, to)| {
Text:         // Convert to the JSON structure the frontend expe...
----------------------------------------
