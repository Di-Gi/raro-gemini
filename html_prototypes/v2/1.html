<!-- 
// [[RARO]]/vision_manifest_v2.html
// Purpose: Interactive Vision Artifact for RARO v2 "Cognitive Fabric".
// Architecture: Single-File HTML5 Application (Canvas + Vanilla JS).
// Dependencies: None (Zero-dependency).
// 
// COMPLETE AND UNABBREVIATED IMPLEMENTATION
// Integration: Open in any modern browser to view the future state simulation.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RARO v2 // COGNITIVE FABRIC</title>
    <style>
        :root {
            --void: #050505;
            --panel: #0a0a0a;
            --grid: #1a1a1a;
            --text: #e0e0e0;
            --dim: #444;
            --accent: #00F0FF; /* Arctic Cyan */
            --accent-glow: rgba(0, 240, 255, 0.3);
            --warn: #FFB300;   /* Amber */
            --danger: #FF2A6D; /* Neon Red */
            --font-mono: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0;
            padding: 0;
            background: var(--void);
            color: var(--text);
            font-family: var(--font-mono);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: grid;
            grid-template-columns: 350px 1fr;
            grid-template-rows: 60px 1fr 40px;
        }

        /* --- HEADER --- */
        header {
            grid-column: 1 / -1;
            border-bottom: 1px solid var(--grid);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(5px);
            z-index: 10;
        }

        .brand {
            font-weight: 700;
            letter-spacing: 2px;
            font-size: 14px;
        }

        .brand span { color: var(--accent); }

        .status-array {
            display: flex;
            gap: 20px;
            font-size: 10px;
            color: var(--dim);
        }

        .status-item { display: flex; align-items: center; gap: 6px; }
        .dot { width: 6px; height: 6px; background: var(--dim); border-radius: 50%; }
        .dot.active { background: var(--accent); box-shadow: 0 0 8px var(--accent); }
        .dot.pulse { animation: pulse 1s infinite alternate; }

        @keyframes pulse { from { opacity: 0.4; } to { opacity: 1; } }

        /* --- SIDEBAR (MANIFEST) --- */
        aside {
            grid-row: 2 / -1;
            border-right: 1px solid var(--grid);
            background: var(--panel);
            padding: 24px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        h2 {
            font-size: 12px;
            color: var(--dim);
            text-transform: uppercase;
            margin: 0 0 12px 0;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--grid);
            padding-bottom: 8px;
        }

        .text-block {
            font-size: 11px;
            line-height: 1.6;
            color: #888;
        }
        
        .text-block p { margin-bottom: 12px; }
        .highlight { color: var(--text); font-weight: bold; }
        .accent-text { color: var(--accent); }

        .control-group {
            margin-top: auto;
            border: 1px solid var(--grid);
            padding: 15px;
            background: rgba(0,0,0,0.2);
        }

        button {
            width: 100%;
            background: var(--grid);
            color: var(--text);
            border: 1px solid var(--dim);
            padding: 12px;
            font-family: var(--font-mono);
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        button:hover {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(0, 240, 255, 0.05);
        }

        button.primary {
            background: var(--accent);
            color: var(--void);
            border-color: var(--accent);
            font-weight: 700;
        }
        
        button.primary:hover {
            background: #fff;
            box-shadow: 0 0 15px var(--accent-glow);
        }

        /* --- MAIN VIEWPORT (CANVAS) --- */
        main {
            grid-column: 2;
            grid-row: 2;
            position: relative;
            background-image: 
                linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            overflow: hidden;
            cursor: crosshair;
        }

        #sim-canvas {
            display: block;
        }

        .hud-overlay {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            pointer-events: none;
        }

        .metric {
            font-size: 32px;
            font-weight: 300;
            color: var(--text);
        }
        .metric-label {
            font-size: 10px;
            color: var(--accent);
            text-transform: uppercase;
        }

        /* --- LOG FOOTER --- */
        footer {
            grid-column: 2;
            grid-row: 3;
            border-top: 1px solid var(--grid);
            background: var(--panel);
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 10px;
            color: var(--accent);
        }

        .log-line {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            animation: typeIn 0.3s ease-out;
        }

        @keyframes typeIn { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }

    </style>
</head>
<body>

    <header>
        <div class="brand">RARO <span>v2.0</span> // VISION_ARTIFACT</div>
        <div class="status-array">
            <div class="status-item"><div class="dot active pulse"></div> NEURAL_BUS_ONLINE</div>
            <div class="status-item"><div class="dot active"></div> META_KERNEL_READY</div>
            <div class="status-item"><div class="dot"></div> GEMINI_2.5_PRO</div>
        </div>
    </header>

    <aside>
        <div>
            <h2>01 // The Shift</h2>
            <div class="text-block">
                <p>Current Orchestration (v1) relies on static pipelines. We define the graph, then run it. This is insufficient for high-entropy research tasks.</p>
                <p>The Future (v2) is <span class="accent-text">Recursive Self-Assembly</span>. Agents do not just produce text; they emit <span class="highlight">Graph Mutation Commands</span>.</p>
            </div>
        </div>

        <div>
            <h2>02 // Architecture</h2>
            <div class="text-block">
                <p><span class="highlight">Meta-Kernel:</span> A high-frequency loop that accepts `SPAWN` and `PRUNE` requests from agents.</p>
                <p><span class="highlight">Vector Core:</span> Replacing JSON passing with a shared latent space. Agents subscribe to semantic neighborhoods.</p>
            </div>
        </div>

        <div class="control-group">
            <h2>Simulation Deck</h2>
            <p class="text-block" style="margin-bottom: 15px;">Inject a high-level goal to observe recursive expansion.</p>
            
            <button class="primary" onclick="sim.injectSeed()">Inject Seed Goal</button>
            <button onclick="sim.reset()">System Purge</button>
            <button onclick="sim.toggleDebug()">Toggle Neural Links</button>
        </div>
        
        <div style="margin-top: auto;">
             <div class="text-block" style="font-size: 9px; opacity: 0.5;">
                 RENDERER: HTML5_CANVAS<br>
                 PHYSICS: VERLET_INTEGRATION<br>
                 MODEL: GEMINI_SIMULACRUM
             </div>
        </div>
    </aside>

    <main id="viewport">
        <canvas id="sim-canvas"></canvas>
        <div class="hud-overlay">
            <div class="metric" id="node-count">00</div>
            <div class="metric-label">Active Nodes</div>
        </div>
    </main>

    <footer>
        <div id="sys-log" class="log-line">> WAITING FOR SEED INJECTION...</div>
    </footer>

    <script>
        /**
         * RARO v2 SIMULATION ENGINE
         * Simulates the "Cognitive Fabric" behavior:
         * 1. Seed Node spawns
         * 2. Seed analyzes and fractures into Sub-Tasks (Spawning children)
         * 3. Children process and may spawn sub-children (Recursion)
         * 4. Nodes complete and send data back to parents (Synthesis)
         */

        class Vec2 {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { return new Vec2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vec2(this.x - v.x, this.y - v.y); }
            mult(n) { return new Vec2(this.x * n, this.y * n); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            norm() { 
                const m = this.mag(); 
                return m === 0 ? new Vec2(0,0) : new Vec2(this.x/m, this.y/m); 
            }
            dist(v) { return this.sub(v).mag(); }
        }

        class Node {
            constructor(id, x, y, type, parent = null) {
                this.id = id;
                this.pos = new Vec2(x, y);
                this.vel = new Vec2(0, 0);
                this.acc = new Vec2(0, 0);
                this.type = type; // 'SEED', 'ROUTER', 'WORKER', 'SYNTH'
                this.parent = parent;
                this.children = [];
                
                // State
                this.life = 0;
                this.status = 'THINKING'; // THINKING, SPAWNING, WORKING, COMPLETE
                this.maxLife = 100 + Math.random() * 100;
                
                // Visuals
                this.radius = type === 'SEED' ? 8 : (type === 'ROUTER' ? 6 : 4);
                this.color = this.getColor();
            }

            getColor() {
                switch(this.type) {
                    case 'SEED': return '#FFFFFF';
                    case 'ROUTER': return '#00F0FF'; // Cyan
                    case 'WORKER': return '#FFB300'; // Amber
                    case 'SYNTH': return '#FF2A6D';  // Red/Pink
                    default: return '#888';
                }
            }

            update(nodes, bounds) {
                this.life++;
                
                // Physics: Repulsion
                nodes.forEach(other => {
                    if (other === this) return;
                    const dir = this.pos.sub(other.pos);
                    const d = dir.mag();
                    if (d < 60) {
                        const force = dir.norm().mult(200 / (d * d + 0.1));
                        this.acc = this.acc.add(force);
                    }
                });

                // Physics: Spring to Parent
                if (this.parent) {
                    const dir = this.parent.pos.sub(this.pos);
                    const d = dir.mag();
                    const targetDist = 80;
                    if (d > targetDist) {
                        this.acc = this.acc.add(dir.norm().mult((d - targetDist) * 0.005));
                    }
                }

                // Physics: Center gravity (weak)
                const center = new Vec2(bounds.w/2, bounds.h/2);
                this.acc = this.acc.add(center.sub(this.pos).mult(0.0005));

                // Apply
                this.vel = this.vel.add(this.acc);
                this.vel = this.vel.mult(0.92); // Friction
                this.pos = this.pos.add(this.vel);
                this.acc = new Vec2(0, 0);

                // Simulation Logic
                this.processLifecycle();
            }

            processLifecycle() {
                // 1. Seed spawns Routers
                if (this.type === 'SEED' && this.life === 60 && this.children.length === 0) {
                    sim.spawnNode(this, 'ROUTER');
                    sim.spawnNode(this, 'ROUTER');
                    sim.spawnNode(this, 'ROUTER');
                    this.status = 'WAITING';
                    sim.log(`SEED [${this.id}] :: STRATEGY FRACTURE -> 3 BRANCHES`);
                }

                // 2. Routers spawn Workers
                if (this.type === 'ROUTER' && this.life === 50 && this.children.length === 0) {
                    const count = Math.floor(Math.random() * 2) + 1;
                    for(let i=0; i<count; i++) sim.spawnNode(this, 'WORKER');
                    this.status = 'WAITING';
                    sim.log(`ROUTER [${this.id}] :: DISCOVERED SUB-TASKS`);
                }

                // 3. Workers work then Complete
                if (this.type === 'WORKER' && this.status === 'THINKING') {
                    if (this.life > this.maxLife) {
                        this.status = 'COMPLETE';
                        sim.log(`WORKER [${this.id}] :: TASK COMPLETE`);
                        // Chance to spawn a deep synthesis node
                        if (Math.random() > 0.8) {
                             sim.spawnNode(this, 'SYNTH');
                             sim.log(`WORKER [${this.id}] :: COMPLEXITY DETECTED -> SPAWNING SYNTH`);
                        }
                    }
                }
            }

            draw(ctx) {
                // Draw Link
                if (this.parent) {
                    ctx.beginPath();
                    ctx.moveTo(this.parent.pos.x, this.parent.pos.y);
                    ctx.lineTo(this.pos.x, this.pos.y);
                    ctx.strokeStyle = this.status === 'COMPLETE' ? '#00F0FF' : 'rgba(255,255,255,0.1)';
                    ctx.lineWidth = this.status === 'COMPLETE' ? 1.5 : 0.5;
                    ctx.stroke();
                }

                // Draw Node
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                
                // Pulse effect if active
                if (this.status === 'THINKING') {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                } else {
                    ctx.shadowBlur = 0;
                }
                
                ctx.fill();
                ctx.fillStyle = '#fff'; // reset
                
                // Label
                ctx.font = '8px monospace';
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillText(this.type[0], this.pos.x + 10, this.pos.y + 3);
            }
        }

        class Simulation {
            constructor() {
                this.canvas = document.getElementById('sim-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.bounds = { w: 0, h: 0 };
                this.resize();
                
                this.nodeCounter = 0;
                this.debugMode = true;

                window.addEventListener('resize', () => this.resize());
                this.loop();
            }

            resize() {
                this.bounds.w = this.canvas.parentElement.clientWidth;
                this.bounds.h = this.canvas.parentElement.clientHeight;
                this.canvas.width = this.bounds.w;
                this.canvas.height = this.bounds.h;
            }

            log(msg) {
                const el = document.getElementById('sys-log');
                el.innerText = `> ${msg}`;
                // Trigger animation reset
                el.style.animation = 'none';
                el.offsetHeight; /* trigger reflow */
                el.style.animation = null; 
            }

            injectSeed() {
                this.reset();
                const seed = new Node(
                    this.getNextId(), 
                    this.bounds.w / 2, 
                    this.bounds.h / 2, 
                    'SEED'
                );
                this.nodes.push(seed);
                this.log('SEED INJECTED: "ANALYZE QUANTUM CRYPTO RISKS"');
            }

            spawnNode(parent, type) {
                // Random offset for spawn
                const angle = Math.random() * Math.PI * 2;
                const dist = 10;
                const x = parent.pos.x + Math.cos(angle) * dist;
                const y = parent.pos.y + Math.sin(angle) * dist;
                
                const node = new Node(this.getNextId(), x, y, type, parent);
                parent.children.push(node);
                this.nodes.push(node);
            }

            getNextId() {
                return (this.nodeCounter++).toString(16).toUpperCase().padStart(3, '0');
            }

            reset() {
                this.nodes = [];
                this.nodeCounter = 0;
                this.log('SYSTEM PURGED. READY.');
            }

            toggleDebug() {
                this.debugMode = !this.debugMode;
            }

            loop() {
                // Clear
                this.ctx.fillStyle = '#050505';
                this.ctx.fillRect(0, 0, this.bounds.w, this.bounds.h);

                // Update
                this.nodes.forEach(n => n.update(this.nodes, this.bounds));

                // Draw Neural Bus (Background connections)
                if (this.debugMode) {
                    this.ctx.strokeStyle = 'rgba(0, 240, 255, 0.03)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    for(let i=0; i<this.nodes.length; i++) {
                        for(let j=i+1; j<this.nodes.length; j++) {
                            const d = this.nodes[i].pos.dist(this.nodes[j].pos);
                            if (d < 150) {
                                this.ctx.moveTo(this.nodes[i].pos.x, this.nodes[i].pos.y);
                                this.ctx.lineTo(this.nodes[j].pos.x, this.nodes[j].pos.y);
                            }
                        }
                    }
                    this.ctx.stroke();
                }

                // Draw Nodes
                this.nodes.forEach(n => n.draw(this.ctx));

                // Update UI
                document.getElementById('node-count').innerText = this.nodes.length.toString().padStart(2, '0');

                requestAnimationFrame(() => this.loop());
            }
        }

        // Init
        const sim = new Simulation();
        
        // Auto-start for effect
        setTimeout(() => sim.injectSeed(), 500);

    </script>
</body>
</html>