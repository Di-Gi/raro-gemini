# [[RARO]]/apps/agent-service/src/domain/protocol.py
# Purpose: Shared Data Models and Domain Enums (DDD Value Objects)
# Architecture: Domain Layer defining the contract between Agent Service and Kernel.
# Dependencies: pydantic

from enum import Enum
from pydantic import BaseModel, Field
from typing import List, Dict, Optional, Any, Literal
from core.config import settings

# ============================================================================
# Enums (Expanded for robust error handling and Pydantic mapping)
# ============================================================================

class AgentRole(str, Enum):
    ORCHESTRATOR = "orchestrator"
    WORKER = "worker"
    OBSERVER = "observer"

class DelegationStrategy(str, Enum):
    CHILD = "child"
    SIBLING = "sibling"

class TriggerType(str, Enum):
    NODE_CREATED = "NodeCreated"
    TOOL_CALL = "ToolCall"
    AGENT_FAILED = "AgentFailed"

class ActionType(str, Enum):
    INTERRUPT = "Interrupt"
    REQUEST_APPROVAL = "RequestApproval"
    SPAWN_AGENT = "SpawnAgent"

# ============================================================================
# Core Definitions
# ============================================================================

class AgentNodeConfig(BaseModel):
    """Configuration for a single agent node within a DAG workflow."""
    id: str = Field(..., description="Unique ID for the agent node")
    role: AgentRole = Field(AgentRole.WORKER, description="Structural role in the graph")
    specialty: str = Field("generalist", description="Functional description, e.g., 'Analyst'")
    
    # UPDATED: Default value now comes from config.py
    model: str = Field(settings.MODEL_FAST, description="Gemini model identifier")
    
    prompt: str = Field(..., description="The system instruction for this specific node")
    tools: List[str] = Field(default_factory=list, description="Capabilities enabled for this agent")
    depends_on: List[str] = Field(default_factory=list, description="IDs of nodes this agent waits for")
    input_schema: Dict[str, Any] = Field(default_factory=dict, description="Expected input JSON structure")
    output_schema: Dict[str, Any] = Field(default_factory=dict, description="Expected output JSON structure")
    accepts_directive: bool = False 
    
class WorkflowManifest(BaseModel):
    """The complete DAG definition generated by the Architect."""
    name: str = Field(..., description="Descriptive name of the workflow")
    agents: List[AgentNodeConfig] = Field(..., description="The sequence/graph of agents to execute")

class DelegationRequest(BaseModel):
    """Payload for an agent requesting dynamic graph expansion."""
    reason: str = Field(..., description="Justification for the delegation")
    strategy: DelegationStrategy = Field(DelegationStrategy.CHILD)
    new_nodes: List[AgentNodeConfig] = Field(..., description="Sub-agents to be spliced into the graph")

# ============================================================================
# Safety Patterns
# ============================================================================

class PatternTrigger(BaseModel):
    type: TriggerType
    condition: str = Field(..., description="Logic filter, e.g., 'tool == fs_delete'")

class PatternAction(BaseModel):
    type: ActionType
    reason: str

class PatternDefinition(BaseModel):
    """Definition of a safety guardrail compiled from natural language policy."""
    id: str
    name: str
    trigger: PatternTrigger
    action: PatternAction

# ============================================================================
# Transport Layer
# ============================================================================

class AgentRequest(BaseModel):
    """Request from the Kernel to execute a specific agent node."""
    agent_id: str
    model: str
    prompt: str
    input_data: Dict[str, Any]

    # === NEW FIELD ===
    # Required for RFS WorkspaceManager to locate the session folder
    run_id: str

    # === DIRECTIVE FIELD ===
    # Separate from prompt to preserve persona/directive distinction
    # Prompt = "You are a Python specialist..." (System Instruction)
    # user_directive = "Analyze this CSV..." (User Message)
    user_directive: str = ""

    tools: List[str] = []
    thought_signature: Optional[str] = None
    parent_signature: Optional[str] = None
    cached_content_id: Optional[str] = None
    thinking_level: Optional[int] = None
    file_paths: List[str] = []

    # [[NEW FIELDS]]
    allow_delegation: bool = False
    graph_view: str = "Context unavailable"

class AgentResponse(BaseModel):
    """Result of an agent execution returned to the Kernel."""
    agent_id: str
    success: bool
    tokens_used: int = 0
    input_tokens: int = 0
    output_tokens: int = 0
    cache_hit: bool = False
    latency_ms: float = 0.0
    thought_signature: Optional[str] = None
    output: Optional[Dict[str, Any]] = None
    error: Optional[str] = None
    delegation: Optional[DelegationRequest] = None

# Integration: Central source of truth for all Pydantic validation across the service.
# Notes: Added run_id to AgentRequest to support RFS integration.