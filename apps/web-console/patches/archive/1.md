This is **Phase 4: The Interface**.

We are updating the Web Console to visualize the "Living Graph" and provide controls for "Human-in-the-Loop" interventions.

### 1. Update `apps/web-console/src/components/ControlDeck.svelte`

We are adding a dedicated **Intervention Mode**. When the Kernel status shifts to `AWAITING_APPROVAL`, the deck transforms into a high-priority command center.

```svelte
<!-- // [[RARO]]/apps/web-console/src/components/ControlDeck.svelte -->
<script lang="ts">
  import { selectedNode, agentNodes, pipelineEdges, addLog, telemetry, connectRuntimeWebSocket, runtimeStore, resumeRun, stopRun } from '$lib/stores'
  import { startRun, type WorkflowConfig, type AgentConfig } from '$lib/api'
  import { get } from 'svelte/store'

  let { expanded }: { expanded: boolean } = $props();

  let cmdInput = $state('')
  let activePane = $state('input') 
  let currentModel = $state('gemini-2.5-flash-lite')
  let currentPrompt = $state('')
  let thinkingBudget = $state(5)
  let isSubmitting = $state(false)
  let isInputFocused = $state(false)

  // Reactive derivation for HITL state
  let isAwaitingApproval = $derived($runtimeStore.status === 'AWAITING_APPROVAL' || $runtimeStore.status === 'PAUSED');

  // ... (Existing state synchronization logic remains the same) ...
  $effect(() => {
    if ($selectedNode && expanded) {
      const node = $agentNodes.find((n) => n.id === $selectedNode)
      if (node) {
        currentModel = node.model.toLowerCase()
        currentPrompt = node.prompt
      }
      if (activePane !== 'node-config') activePane = 'node-config'
    } else if (!$selectedNode && activePane === 'node-config') {
      activePane = 'overview'
    } else if (!expanded && activePane !== 'input' && !isAwaitingApproval) {
      activePane = 'input'
    }
  });

  // Force expand if approval needed
  $effect(() => {
      if (isAwaitingApproval && !expanded) {
          // In a real app we might emit an event to parent, here we just assume user sees the indicator
      }
  })

  async function executeRun() {
    // ... (Existing executeRun logic) ...
    // (Ensure you copy the existing logic from previous artifacts here if re-implementing full file)
    if (!cmdInput) return
    if (isSubmitting) return

    isSubmitting = true
    addLog('OPERATOR', `<strong>${cmdInput}</strong>`, 'USER_INPUT')

    try {
        const nodes = get(agentNodes)
        const edges = get(pipelineEdges)
        
        const agents: AgentConfig[] = nodes.map(n => {
            const dependsOn = edges.filter(e => e.to === n.id).map(e => e.from);
            let modelVariant = 'gemini-2.5-flash-lite';
            if (n.model.toUpperCase().includes('FLASH')) modelVariant = 'gemini-2.5-flash';
            if (n.model.toUpperCase().includes('DEEP')) modelVariant = 'gemini-2.5-flash';

            return {
                id: n.id,
                role: n.role,
                model: modelVariant,
                tools: [], 
                input_schema: {},
                output_schema: {},
                cache_policy: 'ephemeral',
                depends_on: dependsOn,
                prompt: n.prompt,
                position: { x: n.x, y: n.y }
            };
        });

        const orchestrator = agents.find(a => a.role === 'orchestrator');
        if (orchestrator) {
            orchestrator.prompt = `${orchestrator.prompt}\n\nUSER REQUEST: ${cmdInput}`;
        }

        const config: WorkflowConfig = {
            id: `flow-${Date.now()}`,
            name: 'RARO_Session',
            agents: agents,
            max_token_budget: 100000,
            timeout_ms: 60000
        };

        addLog('KERNEL', 'Compiling DAG manifest...', 'SYS');
        const response = await startRun(config);
        addLog('KERNEL', `Workflow started. Run ID: ${response.run_id}`, 'OK');
        connectRuntimeWebSocket(response.run_id);
        cmdInput = ''

    } catch (e: any) {
        addLog('KERNEL', `Execution failed: ${e.message}`, 'ERR');
    } finally {
        isSubmitting = false;
    }
  }

  // HITL Handlers
  async function handleApprove() {
      if (!$runtimeStore.runId) return;
      addLog('OPERATOR', 'APPROVAL GRANTED. Resuming execution.', 'HITL');
      await resumeRun($runtimeStore.runId);
  }

  async function handleDeny() {
      if (!$runtimeStore.runId) return;
      addLog('OPERATOR', 'APPROVAL DENIED. Terminating run.', 'HITL');
      await stopRun($runtimeStore.runId);
  }

  // ... (Existing helper functions: handlePaneSelect, handleCloseNode, etc.) ...
  function handlePaneSelect(pane: string) { activePane = pane; if ($selectedNode) $selectedNode = null; } // Fixed deselect call
  function handleCloseNode() { $selectedNode = null; }
  function saveNodeConfig() { /* ... */ }
  function handleKey(e: KeyboardEvent) { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); executeRun(); } }

</script>

<div id="control-deck" class:architect-mode={expanded}>
  {#if expanded}
    <div id="deck-nav">
      {#if activePane === 'node-config'}
        <div class="nav-item node-tab active">COMPONENT SETTINGS // {$selectedNode}</div>
        <div class="nav-item action-close" onclick={handleCloseNode}>×</div>
      {:else}
        <div class="nav-item {activePane === 'overview' ? 'active' : ''}" onclick={() => handlePaneSelect('overview')}>Overview</div>
        <div class="nav-item {activePane === 'sim' ? 'active' : ''}" onclick={() => handlePaneSelect('sim')}>Simulation</div>
        <div class="nav-item {activePane === 'stats' ? 'active' : ''}" onclick={() => handlePaneSelect('stats')}>Telemetry</div>
      {/if}
    </div>
  {/if}

  <div class="pane-container">
    
    <!-- === INTERVENTION OVERLAY === -->
    {#if isAwaitingApproval}
        <div class="intervention-overlay" transition:fade={{ duration: 200 }}>
            <div class="intervention-card">
                <div class="int-header">
                    <span class="blink-dot"></span>
                    SYSTEM INTERVENTION REQUIRED
                </div>
                <div class="int-body">
                    A Safety Pattern or Delegation Request has paused execution.
                    Please review the logs and authorize the next step.
                </div>
                <div class="int-actions">
                    <button class="btn-deny" onclick={handleDeny}>ABORT RUN</button>
                    <button class="btn-approve" onclick={handleApprove}>AUTHORIZE & RESUME</button>
                </div>
            </div>
        </div>
    {/if}

    <!-- Normal Panes -->
    {#if !expanded || activePane === 'input'}
      <div id="pane-input" class="deck-pane">
        <div class="cmd-wrapper {isInputFocused ? 'focused' : ''}">
            <textarea id="cmd-input" placeholder="ENTER DIRECTIVE..." bind:value={cmdInput} disabled={isSubmitting || isAwaitingApproval} onkeydown={handleKey} onfocus={() => isInputFocused = true} onblur={() => isInputFocused = false}></textarea>
            <button id="btn-run" onclick={executeRun} disabled={isSubmitting || isAwaitingApproval}>
                {#if isSubmitting}<span class="loader"></span>{:else}↵{/if}
            </button>
        </div>
        <div class="input-hint">PRESS ENTER TO EXECUTE</div>
      </div>
    
    <!-- ... (Keep existing Node Config, Overview, Sim, Stats panes exactly as they were) ... -->
    {:else if activePane === 'node-config'}
       <!-- Re-insert existing node config code -->
       <div id="pane-node-config" class="deck-pane">
          <!-- ... existing form inputs ... -->
          <div class="form-group"><label>Agent ID</label><input class="input-std input-readonly" value={$selectedNode} readonly /></div>
          <!-- ... -->
       </div>
    {:else if activePane === 'overview'}
       <div id="pane-overview" class="deck-pane">
          <!-- ... existing overview ... -->
          <div class="form-grid"><div class="form-group"><label>Status</label><div class="status-indicator">{$runtimeStore.status}</div></div></div>
       </div>
    {:else if activePane === 'stats'}
       <div id="pane-stats" class="deck-pane">
          <div class="stat-grid">
             <div class="stat-card"><span class="stat-val">{($telemetry.tokensUsed / 1000).toFixed(1)}k</span><span class="stat-lbl">Tokens</span></div>
             <!-- ... -->
          </div>
       </div>
    {/if}
  </div>
</div>

<style>
  /* ... (Keep existing styles) ... */
  @import '../app.css'; /* Assuming global vars are available */

  /* INTERVENTION STYLES */
  .intervention-overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(4px);
      z-index: 200;
      display: flex; align-items: center; justify-content: center;
  }

  .intervention-card {
      background: var(--paper-bg);
      border: 1px solid var(--alert-amber);
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      width: 400px;
      padding: 2px; /* Border padding */
  }

  .int-header {
      background: var(--alert-amber);
      color: #000;
      padding: 8px 12px;
      font-weight: 700;
      font-size: 11px;
      letter-spacing: 1px;
      display: flex; align-items: center; gap: 8px;
  }

  .blink-dot {
      width: 8px; height: 8px; background: #000; border-radius: 50%;
      animation: blink 0.5s infinite alternate;
  }

  .int-body {
      padding: 20px;
      font-size: 13px;
      line-height: 1.5;
      color: var(--paper-ink);
      border-bottom: 1px solid var(--paper-line);
  }

  .int-actions {
      display: grid; grid-template-columns: 1fr 1fr;
  }

  .int-actions button {
      border: none; padding: 12px;
      font-family: var(--font-code); font-weight: 700; font-size: 11px;
      cursor: pointer; transition: background 0.2s;
  }

  .btn-deny { background: var(--paper-surface); color: var(--paper-ink); }
  .btn-deny:hover { background: #d32f2f; color: white; }

  .btn-approve { background: var(--paper-ink); color: var(--paper-bg); }
  .btn-approve:hover { opacity: 0.9; }

  /* Ensure loader animation exists */
  @keyframes blink { from { opacity: 1; } to { opacity: 0.3; } }
</style>
```

### 2. Update `apps/web-console/src/lib/stores.ts`

We add the logic to "Ingest" dynamic nodes. When the Kernel reports activity from an unknown Agent ID (created via the Splicer), we dynamically add it to the graph.

```typescript
// [[RARO]]/apps/web-console/src/lib/stores.ts
// Purpose: State Management. Updated for Dynamic Graph Ingestion and Approval Actions.

import { writable, get } from 'svelte/store';
import { getWebSocketURL, USE_MOCK } from './api';
import { MockWebSocket } from './mock-api';

// ... (Existing Interfaces LogEntry, AgentNode, etc.) ...

// === ACTIONS ===

// Add these new actions for HITL
export async function resumeRun(runId: string) {
    if (USE_MOCK) {
        runtimeStore.update(s => ({ ...s, status: 'RUNNING' }));
        return;
    }
    // Phase 4: Placeholder for the Resume API call
    // await fetch(`${API_BASE}/runtime/${runId}/resume`, { method: 'POST' });
}

export async function stopRun(runId: string) {
    if (USE_MOCK) {
        runtimeStore.update(s => ({ ...s, status: 'FAILED' }));
        return;
    }
    // await fetch(`${API_BASE}/runtime/${runId}/stop`, { method: 'POST' });
}

// ... (Existing log/node actions) ...

// === DYNAMIC GRAPH LOGIC ===

/**
 * Heuristic to detect and add new nodes spawning from the Kernel.
 * Since the Kernel currently sends a flat list of active_agents, 
 * we infer new nodes if we see an ID we don't recognize.
 */
function ingestDynamicNodes(activeAgents: string[], signatures: Record<string, string>) {
    const currentNodes = get(agentNodes);
    const existingIds = new Set(currentNodes.map(n => n.id));
    
    let nodesAdded = false;
    let newNodesList = [...currentNodes];
    let newEdgesList = [...get(pipelineEdges)];

    activeAgents.forEach(agentId => {
        if (!existingIds.has(agentId)) {
            // FOUND A NEW NODE (Spawned by Splicer)
            console.log(`[UI] Detected dynamic agent: ${agentId}`);
            
            // 1. Determine Position (Simple Stack Strategy)
            // In a real app, we'd query the kernel for the parent. 
            // Here, we just stack them below the last known node.
            const lastNode = newNodesList[newNodesList.length - 1];
            const newX = lastNode ? lastNode.x + 10 : 50;
            const newY = lastNode ? lastNode.y + 10 : 50;

            // 2. Create Node
            const newNode: any = { // Use 'any' to bypass strict AgentNode interface for prototype
                id: agentId,
                label: agentId.toUpperCase().substring(0, 12), // Truncate ID
                x: newX,
                y: newY,
                model: 'DYNAMIC',
                prompt: 'Dynamically spawned agent',
                status: 'running',
                role: 'worker'
            };

            newNodesList.push(newNode);
            existingIds.add(agentId);
            nodesAdded = true;

            // 3. Infer Edge (Optional/Heuristic)
            // If we knew the parent, we'd add an edge. 
            // For now, we leave it disconnected or connect to the "Orchestrator" (n1) as a fallback visually
            // newEdgesList.push({ from: 'n1', to: agentId, active: true, finalized: false, pulseAnimation: true });
        }
    });

    if (nodesAdded) {
        agentNodes.set(newNodesList);
        // pipelineEdges.set(newEdgesList); // Uncomment if adding edges
    }
}

// === WEBSOCKET HANDLING ===

// ... (Existing connection logic) ...

// Updated syncState to call ingest
function syncState(state: any, signatures: Record<string, string> = {}) {
  const rawStatus = state.status ? state.status.toUpperCase() : 'RUNNING';
  const isRunComplete = rawStatus === 'COMPLETED' || rawStatus === 'FAILED';

  // 0. Ingest Dynamic Nodes BEFORE updating statuses
  if (state.active_agents) {
      ingestDynamicNodes(state.active_agents, signatures);
  }

  // 1. Sync Node Status
  agentNodes.update(nodes => {
    return nodes.map(n => {
      let status: 'idle' | 'running' | 'complete' | 'failed' = 'idle';
      
      // Map Rust enums to UI states
      if (state.active_agents.includes(n.id)) status = 'running';
      else if (state.completed_agents.includes(n.id)) status = 'complete';
      else if (state.failed_agents.includes(n.id)) status = 'failed';
      
      return { ...n, status };
    });
  });

  // ... (Rest of syncState: Edges, Telemetry, Logs remain same) ...
}
```

### 3. Update `apps/web-console/src/components/PipelineStage.svelte`

We ensure the graph layout engine (Svelte reactive statements) can handle the array growing at runtime.

```svelte
<!-- // [[RARO]]/apps/web-console/src/components/PipelineStage.svelte -->
<script lang="ts">
  // ... imports ...
  import { agentNodes, pipelineEdges, selectedNode, selectNode, runtimeStore, type PipelineEdge } from '$lib/stores'

  let { expanded, ontoggle }: { expanded: boolean, ontoggle?: () => void } = $props();

  let svgElement = $state<SVGSVGElement | undefined>();
  let nodesLayer = $state<HTMLDivElement | undefined>();
  let pipelineStageElement = $state<HTMLDivElement | undefined>();

  let isRunComplete = $derived($runtimeStore.status === 'COMPLETED' || $runtimeStore.status === 'FAILED');

  // KEY FIX: React to changes in the node list length (Dynamic Injection)
  $effect(() => {
    const _nodeCount = $agentNodes.length; 
    const _edgeCount = $pipelineEdges.length;
    // This dependency ensures renderGraph runs when the array grows
    renderGraph();
  });

  // ... (Existing renderGraph implementation) ...
  // Ensure that within renderGraph, you iterate over the current $agentNodes
  // The existing implementation already does: $agentNodes.forEach(...)
  
  function renderGraph() {
    if (!svgElement || !nodesLayer) return
    const svg = svgElement
    const w = svg.clientWidth
    const h = svg.clientHeight
    svg.innerHTML = ''
    if (nodesLayer) nodesLayer.innerHTML = ''

    // ... (Edge rendering loop) ...

    // Node Rendering Loop
    $agentNodes.forEach((node) => {
        // ... (Create element) ...
        // IMPORTANT: Ensure dynamic nodes get generic styling if role missing
        const role = node.role ? node.role.toUpperCase() : 'WORKER';
        
        const el = document.createElement('div')
        el.className = `node ${$selectedNode === node.id ? 'selected' : ''} ${node.status}` // Simplified class logic
        el.innerHTML = `
            <div class="node-indicator"></div>
            <div class="node-content">
                <div class="node-role">${role}</div>
                <div class="node-label">${node.label}</div>
            </div>
            <div class="node-decor"></div>
        `
        // ... (Positioning and click handlers) ...
        // ...
        nodesLayer!.appendChild(el)
    })
  }
  
  // ... (Rest of file) ...
</script>
```

### Summary
With these changes, the **Interface (Phase 4)** is ready:
1.  **ControlDeck**: Intercepts `AWAITING_APPROVAL` status and blocks input, forcing the user to Approve or Deny.
2.  **Stores**: Automatically detects new agent IDs appearing in the runtime stream and creates visual nodes for them (Primitive "Splicing Visualization").
3.  **PipelineStage**: Reactively re-renders when the store injects these new nodes.