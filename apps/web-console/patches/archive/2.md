The Kernel already exposes `topology` in the WebSocket stream (seen in `handlers.rs`). We just need to stop ignoring it and stop using the heuristic `ingestDynamicNodes` function.

Here is the clean implementation that relies entirely on the Kernel's authoritative topology.

### 1. The Layout Engine (`src/lib/layout-engine.ts`)

This remains the purely mathematical component. It takes a raw topology (nodes + edges) and returns normalized `x/y` coordinates (0-100%) so the graph fits the view perfectly, regardless of complexity.

**Create this file:**

```typescript
// [[RARO]]/apps/web-console/src/lib/layout-engine.ts
import type { AgentNode, PipelineEdge } from './stores';

export class DagLayoutEngine {
    /**
     * Deterministic layout calculation based on Kernel topology.
     * Uses a "Longest Path" layering algorithm (Rank Assignment).
     */
    static computeLayout(currentNodes: AgentNode[], edges: PipelineEdge[]): AgentNode[] {
        if (currentNodes.length === 0) return [];

        // 1. Build Adjacency & In-Degree
        const adj = new Map<string, string[]>();
        const inDegree = new Map<string, number>();
        
        currentNodes.forEach(n => {
            adj.set(n.id, []);
            inDegree.set(n.id, 0);
        });

        edges.forEach(e => {
            // Only map edges where both nodes exist in our current set
            if (adj.has(e.from) && inDegree.has(e.to)) {
                adj.get(e.from)?.push(e.to);
                inDegree.set(e.to, (inDegree.get(e.to) || 0) + 1);
            }
        });

        // 2. Assign Ranks (X-Axis)
        // Rank 0 = Root / Start. Rank N = End.
        const ranks = new Map<string, number>();
        const queue: string[] = [];

        // Identify Roots
        currentNodes.forEach(n => {
            if ((inDegree.get(n.id) || 0) === 0) {
                ranks.set(n.id, 0);
                queue.push(n.id);
            }
        });

        // Fallback: If cycle or no root, force first node as root to unblock layout
        if (queue.length === 0 && currentNodes.length > 0) {
            ranks.set(currentNodes[0].id, 0);
            queue.push(currentNodes[0].id);
        }

        // BFS Traversal
        while (queue.length > 0) {
            const u = queue.shift()!;
            const currentRank = ranks.get(u)!;
            
            const neighbors = adj.get(u) || [];
            neighbors.forEach(v => {
                const existingRank = ranks.get(v) || 0;
                // Push child to (Parent Rank + 1)
                const newRank = Math.max(existingRank, currentRank + 1);
                ranks.set(v, newRank);
                
                // Add to queue if not strictly processed in this path
                if (!queue.includes(v)) queue.push(v);
            });
        }

        // 3. Group by Rank (Y-Axis distribution)
        const layers = new Map<number, string[]>();
        let maxRank = 0;

        ranks.forEach((rank, nodeId) => {
            if (!layers.has(rank)) layers.set(rank, []);
            layers.get(rank)?.push(nodeId);
            if (rank > maxRank) maxRank = rank;
        });

        // 4. Calculate Coordinates (0-100%)
        // Margins keep nodes off the absolute edge of the container
        const MARGIN_X = 10; 
        const MARGIN_Y = 15;
        const AVAILABLE_W = 100 - (MARGIN_X * 2);
        const AVAILABLE_H = 100 - (MARGIN_Y * 2);

        return currentNodes.map(node => {
            const rank = ranks.get(node.id) || 0;
            const layerNodes = layers.get(rank)!;
            
            // X: Normalize based on max depth
            const xPercent = maxRank === 0 
                ? 50 
                : MARGIN_X + (rank / maxRank) * AVAILABLE_W;

            // Y: Distribute evenly in the column
            // We sort by ID to ensure stability between renders (prevents jumping)
            layerNodes.sort(); 
            const indexInLayer = layerNodes.indexOf(node.id);
            const countInLayer = layerNodes.length;
            
            const yPercent = MARGIN_Y + ((indexInLayer + 1) / (countInLayer + 1)) * AVAILABLE_H;

            return {
                ...node,
                x: xPercent,
                y: yPercent
            };
        });
    }
}
```

### 2. Update `stores.ts`

This is where we remove the "monkey-patching". We delete `ingestDynamicNodes` entirely. Instead, `syncTopology` becomes the master logic that trusts the Kernel's `topology` object (which includes the new edges created by delegation).

**File:** `apps/web-console/src/lib/stores.ts`

```typescript
import { writable, get } from 'svelte/store';
import { getWebSocketURL, USE_MOCK, type WorkflowConfig, getArtifact } from './api';
import { MockWebSocket } from './mock-api';
import { DagLayoutEngine } from './layout-engine'; // IMPORT LAYOUT ENGINE

// ... [Keep existing Interfaces: LogEntry, AgentNode, PipelineEdge, TelemetryState] ...

// ... [Keep existing Stores: logs, runtimeStore, themeStore, etc.] ...

// ... [Keep actions: loadWorkflowManifest, addLog, etc.] ...

// ==========================================================
// REMOVE: ingestDynamicNodes() function completely.
// ==========================================================

// === REPLACEMENT: Authoritative Topology Sync ===
function syncTopology(topology: { nodes: string[], edges: { from: string, to: string }[] }) {
    const currentNodes = get(agentNodes);
    const currentEdges = get(pipelineEdges);
    
    // 1. Reconcile Edges (Source of Truth)
    // We rebuild the edge list based on Kernel topology to ensure we capture rewiring
    // (e.g. if Kernel removes an edge during splice, we should remove it too)
    const newEdges: PipelineEdge[] = topology.edges.map(kEdge => {
        // Try to preserve animation state if edge already existed
        const existing = currentEdges.find(e => e.from === kEdge.from && e.to === kEdge.to);
        return {
            from: kEdge.from,
            to: kEdge.to,
            active: existing ? existing.active : false,
            finalized: existing ? existing.finalized : false,
            pulseAnimation: existing ? existing.pulseAnimation : false,
            signatureHash: existing ? existing.signatureHash : undefined
        };
    });

    // 2. Reconcile Nodes
    const nodeMap = new Map(currentNodes.map(n => [n.id, n]));
    const newNodes: AgentNode[] = [];
    let structureChanged = false;

    // Check for edge count mismatch or node count mismatch
    if (newEdges.length !== currentEdges.length || topology.nodes.length !== currentNodes.length) {
        structureChanged = true;
    }

    topology.nodes.forEach(nodeId => {
        if (nodeMap.has(nodeId)) {
            // Existing node: Keep it, just preserve state
            newNodes.push(nodeMap.get(nodeId)!);
        } else {
            // NEW NODE DETECTED (Delegation)
            // We initialize it at 0,0. The Layout Engine will move it immediately.
            structureChanged = true;
            newNodes.push({
                id: nodeId,
                // Heuristic Labeling since Kernel currently sends IDs only in topology
                label: nodeId.toUpperCase().substring(0, 12), 
                x: 0, 
                y: 0,
                model: 'DYNAMIC', // Visual indicator
                prompt: 'Dynamic Agent',
                status: 'running', // Usually spawned active
                role: 'worker'
            });
        }
    });

    // 3. APPLY LAYOUT (Only if structure changed)
    if (structureChanged) {
        console.log('[UI] Topology mutation detected. Recalculating layout...');
        const layoutNodes = DagLayoutEngine.computeLayout(newNodes, newEdges);
        agentNodes.set(layoutNodes);
        pipelineEdges.set(newEdges);
    } else {
        // If structure is same, we might still update edges if they were just re-created
        // But we usually let syncState handle status updates.
        // We set pipelineEdges here to ensure any strict rewiring (deletions) is respected.
        pipelineEdges.set(newEdges);
    }
}


// === UPDATED: WebSocket Message Handler ===

export function connectRuntimeWebSocket(runId: string) {
    // ... [WebSocket setup code remains same] ...

    ws.onmessage = (event: any) => {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'state_update' && data.state) {
                
                // 1. Sync Topology FIRST (Create nodes/edges)
                // The Kernel sends "topology" in the JSON payload
                if (data.topology) {
                    syncTopology(data.topology);
                }

                // 2. Sync Statuses (Color nodes, animate edges)
                // This function now just updates props on existing nodes
                syncState(data.state, data.signatures);

                if (data.state.status) {
                    runtimeStore.update(s => ({ ...s, status: data.state.status.toUpperCase() }));
                }
            }
            // ... [Error handling] ...
        } catch (e) {
            console.error('[WS] Error:', e);
        }
    };
    // ...
}

// === UPDATED: syncState ===
// (Removed the ingestDynamicNodes call from here)

function syncState(state: any, signatures: Record<string, string> = {}) {
    // 1. Status Update (Nodes exist now thanks to syncTopology)
    agentNodes.update(nodes => {
        return nodes.map(n => {
            let status: 'idle' | 'running' | 'complete' | 'failed' = 'idle';
            if (state.active_agents.includes(n.id)) status = 'running';
            else if (state.completed_agents.includes(n.id)) status = 'complete';
            else if (state.failed_agents.includes(n.id)) status = 'failed';
            return { ...n, status };
        });
    });

    // 2. Animation Update
    pipelineEdges.update(edges => {
        return edges.map(e => {
            const fromComplete = state.completed_agents.includes(e.from);
            const toStarted = state.active_agents.includes(e.to) || state.completed_agents.includes(e.to);
            
            // Logic: Line is active if Parent is done AND Child has started
            const hasDataFlowed = fromComplete && toStarted;
            
            // Check for run completion
            const rawStatus = state.status ? state.status.toLowerCase() : 'running';
            const isRunComplete = rawStatus === 'completed' || rawStatus === 'failed';

            return {
                ...e,
                active: hasDataFlowed && !isRunComplete,
                finalized: hasDataFlowed && isRunComplete,
                pulseAnimation: state.active_agents.includes(e.to),
                signatureHash: signatures[e.from]
            };
        });
    });

    // ... [Telemetry & Logs sync remains same] ...
}
```

### 3. Update `PipelineStage.svelte` (Visuals)

Ensure the dynamic nodes stand out and edges curve correctly regardless of distance.

**File:** `apps/web-console/src/components/PipelineStage.svelte`

```svelte
<!-- Inside renderGraph function -->
<script>
    // ...
    $pipelineEdges.forEach((link) => {
        // ... find nodes ...
        
        // Dynamic Bezier Depth
        const dist = Math.abs(x2 - x1);
        const curveDepth = Math.max(dist * 0.4, 40); // 40% of distance or min 40px

        const d = `M ${x1} ${y1} C ${x1 + curveDepth} ${y1}, ${x2 - curveDepth} ${y2}, ${x2} ${y2}`
        
        // ... set attributes ...
    })

    if (nodesLayer) {
        nodesLayer.innerHTML = ''
        $agentNodes.forEach((node) => {
            const el = document.createElement('div')
            
            // Check Model for Dynamic Flag
            const isDynamic = node.model === 'DYNAMIC';

            el.className = `node ${$selectedNode === node.id ? 'selected' : ''} ${
                node.status === 'running' ? 'running' : ''
            } ${node.status === 'complete' ? 'complete' : ''} ${isDynamic ? 'node-dynamic' : ''}`

            // Badge
            const badge = isDynamic ? `<span class="badge-dyn">NEW</span>` : '';
            const role = node.role ? node.role.toUpperCase() : 'WORKER';

            el.innerHTML = `
                <div class="node-indicator"></div>
                <div class="node-content">
                    <div class="node-role">${role}</div>
                    <div class="node-label">${node.label} ${badge}</div>
                </div>
                <div class="node-decor"></div>
            `
            // ... positioning logic ...
            // ... click handlers ...
            nodesLayer.appendChild(el)
        })
    }
</script>

<style>
    /* ... existing styles ... */
    
    :global(.node.node-dynamic) {
        border-style: dashed;
        background: color-mix(in srgb, var(--digi-panel), var(--arctic-lilac) 8%);
    }

    :global(.badge-dyn) {
        font-size: 7px;
        background: var(--arctic-lilac);
        color: white;
        padding: 1px 3px;
        border-radius: 2px;
        margin-left: 4px;
        vertical-align: middle;
        animation: pulse 2s infinite;
    }
</style>
```

### Summary of Changes

1.  **Removed Heuristics:** `ingestDynamicNodes` is gone. We no longer guess where nodes go or who they connect to.
2.  **Kernel Authority:** `syncTopology` listens to the `topology` object sent by the Kernel. It rebuilds the edge list exactly as the Kernel sees it.
3.  **Visual Stability:** `DagLayoutEngine` normalizes the graph to 0-100% space. If the Kernel adds a node and an edge, the engine calculates the rank, pushes the graph out, and ensures the new node fits on screen.
4.  **Feedback:** The `console.log('[UI] Topology mutation detected...')` will now fire reliably because it's tied to the WS data payload, not a frontend guess.