// [[RARO]]/apps/web-console/src/lib/mock-api.ts
import { type WorkflowConfig } from './api';

// --- Types ---
type TopologySnapshot = {
    nodes: string[];
    edges: Array<{ from: string; to: string }>;
};

type SimulationStep = {
    delay: number;
    state: {
        status: string;
        active_agents: string[];
        completed_agents: string[];
        failed_agents: string[];
        total_tokens_used: number;
        invocations: Array<{
            id: string;
            agent_id: string;
            status: 'success' | 'failed';
            tokens_used: number;
            latency_ms: number;
            artifact_id?: string;
            error_message?: string;
        }>;
    };
    signatures?: Record<string, string>;
    topology?: TopologySnapshot;
};

// --- Mock Data Generators ---

// Helper to generate the strict JSON format required by the Agent Service parser
const generateDelegationArtifact = (reason: string, parentId: string, newAgentId: string) => {
    const payload = {
        reason: reason,
        strategy: "child",
        new_nodes: [
            {
                id: newAgentId,
                role: "worker",
                model: "gemini-2.5-flash",
                prompt: `Dynamically delegated task from ${parentId}`,
                tools: ["web_search"],
                depends_on: [parentId]
            }
        ]
    };

    return `I need to delegate a sub-task to handle this request properly.

\`\`\`json:delegation
${JSON.stringify(payload, null, 2)}
\`\`\`

Delegating execution to ${newAgentId}...`;
};

const STATIC_ARTIFACTS: Record<string, any> = {
    'n1': { 
        result: `## Orchestration Plan
Analysis indicates a need for deep retrieval and verification.
1. **Retrieval**: Gather architecture docs.
2. **Analysis**: Profile latency metrics.
3. **Synthesis**: Generate final report.`
    },
    'n3': { 
        result: "testing\n```python\n# Analyzing latency variance\nvar = data['p99'].var()\nprint(f'Variance: {var}')\n```\n**Output:** `Variance: 0.042`" 
    },
    'n4': { 
        result: `# Final Report
The analysis confirms that the latency regression is caused by "Cold Expert" switching in the MoE layer.
**Recommendation**: Enable pre-warming on the Orchestrator.`
    }
};

// --- API Methods ---

export async function mockStartRun(config: WorkflowConfig): Promise<{ success: boolean; run_id: string }> {
    console.log('[MOCK] Starting run with config:', config);
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({
                success: true,
                run_id: `mock-run-${Date.now()}`
            });
        }, 500);
    });
}

// Global artifact store to hold dynamic outputs during a session
let SESSION_ARTIFACTS: Record<string, any> = {};

export async function mockGetArtifact(runId: string, agentId: string): Promise<any> {
    console.log(`[MOCK] Fetching artifact for ${agentId}`);
    return new Promise((resolve) => {
        setTimeout(() => {
            // Check session artifacts (dynamic) first, then static
            const artifact = SESSION_ARTIFACTS[agentId] || STATIC_ARTIFACTS[agentId];
            resolve(artifact || { text: `[MOCK] Output generated by agent ${agentId}.` });
        }, 600); 
    });
}

// --- Mock WebSocket Class ---

export class MockWebSocket {
    url: string;
    onopen: (() => void) | null = null;
    onmessage: ((event: { data: string }) => void) | null = null;
    onclose: ((e: { code: number; reason: string; wasClean: boolean }) => void) | null = null;
    
    onerror: ((err: any) => void) | null = null;
    
    private steps: SimulationStep[] = [];
    private currentStep = 0;
    private timer: any;

    // Current State Trackers
    private topology: TopologySnapshot;
    private activeAgents: string[] = [];
    private completedAgents: string[] = [];
    private invocations: any[] = [];
    private signatures: Record<string, string> = {};
    private totalTokens = 0;

    constructor(url: string) {
        this.url = url;
        
        // Reset Artifacts
        SESSION_ARTIFACTS = {};
        
        // Initial Topology
        this.topology = {
            nodes: ['n1', 'n2', 'n3', 'n4'],
            edges: [
                { from: 'n1', to: 'n2' },
                { from: 'n1', to: 'n3' },
                { from: 'n2', to: 'n4' },
                { from: 'n3', to: 'n4' }
            ]
        };

        // Build the dynamic scenario
        this.planSimulation();
        
        // Start simulation loop
        setTimeout(() => {
            if (this.onopen) this.onopen();
            this.runLoop();
        }, 500);
    }

    send(data: any) {
        console.log('[MOCK WS] Received:', data);
    }

    close() {
        console.log('[MOCK WS] Closing connection');
        clearTimeout(this.timer);
        
        // FIX 2: Pass a mock CloseEvent object
        if (this.onclose) {
            this.onclose({ 
                code: 1000, 
                reason: 'Mock Simulation Ended', 
                wasClean: true 
            });
        }
    }

    /**
     * Procedurally generates a simulation timeline with random delegation.
     */
    private planSimulation() {
        // 1. Start State
        this.addStep(500, 'RUNNING');

        // 2. Orchestrator (n1) runs
        this.simulateAgentExecution('n1', 1500, 450);

        // 3. Fork: n2 (Retrieval) and n3 (Code) run in parallel
        // We simulate this by queuing them. n3 is static. n2 is dynamic.
        
        // Start both
        this.activeAgents.push('n2', 'n3');
        this.addStep(200); // Visual update that they are running

        // Complete n3 (Static path)
        this.simulateAgentCompletion('n3', 2500, 800, false);

        // Handle n2 (The Dynamic Path)
        this.processDynamicChain('n2', 'n4'); // n2 -> ... -> n4

        // 4. Synthesis (n4) runs (Waits for n3 and the n2-chain)
        this.simulateAgentExecution('n4', 3000, 2500);

        // 5. Completion
        this.addStep(1000, 'COMPLETED');
    }

    /**
     * Recursively simulates a chain of agents that might delegate.
     * @param currentId The agent currently running
     * @param finalDependentId The node that is waiting for this chain to finish (n4)
     */
    private processDynamicChain(currentId: string, finalDependentId: string) {
        // Random chance to delegate (60% for n2, 30% for others)
        const isRoot = currentId === 'n2';
        const chance = isRoot ? 0.6 : 0.3;
        const shouldDelegate = Math.random() < chance;

        // Ensure we don't go too deep (infinite recursion guard)
        const depth = currentId.split('_').length;
        const limitReached = depth > 3;

        if (shouldDelegate && !limitReached) {
            // --- DELEGATION PATH ---
            const newAgentId = `${currentId}_sub${Math.floor(Math.random() * 100)}`;
            const reason = isRoot 
                ? "Topic too broad; spawning specialist." 
                : "Additional verification required.";

            // 1. Generate Delegation Artifact
            const output = generateDelegationArtifact(reason, currentId, newAgentId);
            SESSION_ARTIFACTS[currentId] = { result: output };

            // 2. Complete Current Agent
            this.activeAgents = this.activeAgents.filter(id => id !== currentId);
            this.completedAgents.push(currentId);
            this.totalTokens += 500;
            
            this.invocations.push({
                id: `inv-${currentId}`,
                agent_id: currentId,
                status: 'success',
                tokens_used: 500,
                latency_ms: 1200,
                artifact_id: `mock-art-${currentId}`
            });

            // 3. MUTATE TOPOLOGY (Graph Surgery)
            this.topology.nodes.push(newAgentId);
            
            // Add edge: Current -> New
            this.topology.edges.push({ from: currentId, to: newAgentId });
            
            // Rewire dependent: New -> Final
            // Remove Old: Current -> Final
            this.topology.edges = this.topology.edges.filter(e => 
                !(e.from === currentId && e.to === finalDependentId)
            );
            // Add New: New -> Final
            this.topology.edges.push({ from: newAgentId, to: finalDependentId });

            // 4. Emit Update with New Topology
            this.signatures[currentId] = `hash_${currentId}`;
            this.addStep(1000); 

            // 5. Start New Agent
            this.activeAgents.push(newAgentId);
            this.addStep(500);

            // 6. Recurse
            this.processDynamicChain(newAgentId, finalDependentId);

        } else {
            // --- STANDARD EXECUTION PATH ---
            SESSION_ARTIFACTS[currentId] = { 
                result: `Analysis complete for node ${currentId}. Validated 100% data points.` 
            };
            
            this.simulateAgentCompletion(currentId, 1500 + Math.random() * 1000, 600, true);
        }
    }

    private simulateAgentExecution(id: string, duration: number, tokens: number) {
        // Start
        if (!this.activeAgents.includes(id)) {
            this.activeAgents.push(id);
        }
        this.addStep(200);

        // Finish
        this.simulateAgentCompletion(id, duration, tokens, false);
    }

    private simulateAgentCompletion(id: string, duration: number, tokens: number, isDynamic: boolean) {
        this.addStep(duration, undefined, () => {
            this.activeAgents = this.activeAgents.filter(a => a !== id);
            this.completedAgents.push(id);
            this.totalTokens += tokens;
            this.signatures[id] = `hash_${Math.floor(Math.random()*10000).toString(16)}`;
            
            this.invocations.push({
                id: `inv-${id}`,
                agent_id: id,
                status: 'success',
                tokens_used: tokens,
                latency_ms: duration,
                artifact_id: `mock-art-${id}`
            });
        });
    }

    private addStep(delay: number, statusOverride?: string, action?: () => void) {
        // We defer the state capture until the step actually runs (lazy eval)
        // or we capture a snapshot now. For simplicity in this procedural generator,
        // we push a closure that updates state, then captures it.
        
        // Actually, to keep the `steps` array static-like structure but generated dynamically:
        // We create a step object. But since we are generating procedurally, 
        // we can't capture 'future' state.
        // We will execute the 'action' then snapshot the state.
        
        if (action) action();

        const snapshot = {
            delay,
            state: {
                status: statusOverride || 'RUNNING',
                active_agents: [...this.activeAgents],
                completed_agents: [...this.completedAgents],
                failed_agents: [],
                total_tokens_used: this.totalTokens,
                invocations: [...this.invocations]
            },
            signatures: { ...this.signatures },
            topology: JSON.parse(JSON.stringify(this.topology)) // Deep copy topology
        };

        this.steps.push(snapshot);
    }

    private runLoop() {
        if (this.currentStep >= this.steps.length) {
            this.close();
            return;
        }

        const step = this.steps[this.currentStep];
        
        this.timer = setTimeout(() => {
            const message = {
                type: 'state_update',
                state: step.state,
                signatures: step.signatures || {},
                topology: step.topology || null
            };

            if (this.onmessage) {
                this.onmessage({ data: JSON.stringify(message) });
            }

            this.currentStep++;
            this.runLoop();
        }, step.delay);
    }
}