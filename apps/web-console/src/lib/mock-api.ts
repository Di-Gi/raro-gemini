// [[RARO]]/apps/web-console/src/lib/mock-api.ts
import { type WorkflowConfig } from './api';

// --- Types ---
type TopologySnapshot = {
    nodes: string[];
    edges: Array<{ from: string; to: string }>;
};

type SimulationStep = {
    delay: number;
    state: {
        status: string;
        active_agents: string[];
        completed_agents: string[];
        failed_agents: string[];
        total_tokens_used: number;
        invocations: Array<{
            id: string;
            agent_id: string;
            status: 'success' | 'failed';
            tokens_used: number;
            latency_ms: number;
            artifact_id?: string;
            error_message?: string;
        }>;
    };
    signatures?: Record<string, string>;
    topology?: TopologySnapshot;
};

// --- Mock Data Generators ---

const generateDelegationArtifact = (reason: string, parentId: string, newAgentId: string) => {
    const payload = {
        reason: reason,
        strategy: "child",
        new_nodes: [
            {
                id: newAgentId,
                role: "worker",
                model: "gemini-2.5-flash",
                prompt: `Dynamically delegated task from ${parentId}`,
                tools: ["web_search"],
                depends_on: [parentId]
            }
        ]
    };

    return `I need to delegate a sub-task to handle this request properly.

\`\`\`json:delegation
${JSON.stringify(payload, null, 2)}
\`\`\`

Delegating execution to ${newAgentId}...`;
};

const STATIC_ARTIFACTS: Record<string, any> = {
    'n1': { 
        result: `## Orchestration Plan
Analysis indicates a need for deep retrieval and verification.
1. **Retrieval**: Gather architecture docs.
2. **Analysis**: Profile latency metrics.
3. **Synthesis**: Generate final report.`
    },
    'n3': { 
        result: "testing\n```python\n# Analyzing latency variance\nvar = data['p99'].var()\nprint(f'Variance: {var}')\n```\n**Output:** `Variance: 0.042`" 
    },
    'n4': { 
        result: `# Final Report
The analysis confirms that the latency regression is caused by "Cold Expert" switching in the MoE layer.
**Recommendation**: Enable pre-warming on the Orchestrator.`
    }
};

// --- Singleton for Controlling the Active Simulation ---
let activeSocket: MockWebSocket | null = null;

// --- API Methods ---

export async function mockStartRun(config: WorkflowConfig): Promise<{ success: boolean; run_id: string }> {
    console.log('[MOCK] Starting run with config:', config);
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve({
                success: true,
                run_id: `mock-run-${Date.now()}`
            });
        }, 500);
    });
}

// Global artifact store to hold dynamic outputs during a session
let SESSION_ARTIFACTS: Record<string, any> = {};

export async function mockGetArtifact(runId: string, agentId: string): Promise<any> {
    console.log(`[MOCK] Fetching artifact for ${agentId}`);
    return new Promise((resolve) => {
        setTimeout(() => {
            const artifact = SESSION_ARTIFACTS[agentId] || STATIC_ARTIFACTS[agentId];
            resolve(artifact || { text: `[MOCK] Output generated by agent ${agentId}.` });
        }, 600); 
    });
}

// ** NEW: Mock Pause/Resume Handlers **
export async function mockResumeRun(runId: string): Promise<void> {
    console.log(`[MOCK] Resuming run ${runId}`);
    if (activeSocket) {
        activeSocket.resume();
    }
}

export async function mockStopRun(runId: string): Promise<void> {
    console.log(`[MOCK] Stopping run ${runId}`);
    if (activeSocket) {
        activeSocket.close();
    }
}

// === NEW MOCK RFS ===
export async function mockGetLibraryFiles(): Promise<string[]> {
    return [
        'financials_Q3_2024.pdf',
        'system_architecture_v2.md',
        'raw_telemetry_dump.csv',
        'cortex_safety_policy.json'
    ];
}


// --- Mock WebSocket Class ---

export class MockWebSocket {
    url: string;
    onopen: (() => void) | null = null;
    onmessage: ((event: { data: string }) => void) | null = null;
    onclose: ((e: { code: number; reason: string; wasClean: boolean }) => void) | null = null;
    onerror: ((err: any) => void) | null = null;
    
    private steps: SimulationStep[] = [];
    private currentStep = 0;
    private timer: any;
    private isPaused = false;

    // Current State Trackers
    private topology: TopologySnapshot;
    private activeAgents: string[] = [];
    private completedAgents: string[] = [];
    private invocations: any[] = [];
    private signatures: Record<string, string> = {};
    private totalTokens = 0;

    constructor(url: string) {
        this.url = url;
        activeSocket = this; // Register singleton
        
        SESSION_ARTIFACTS = {};
        
        this.topology = {
            nodes: ['n1', 'n2', 'n3', 'n4'],
            edges: [
                { from: 'n1', to: 'n2' },
                { from: 'n1', to: 'n3' },
                { from: 'n2', to: 'n4' },
                { from: 'n3', to: 'n4' }
            ]
        };

        this.planSimulation();
        
        setTimeout(() => {
            if (this.onopen) this.onopen();
            this.runLoop();
        }, 500);
    }

    // Called by the external mockResumeRun API
    resume() {
        if (this.isPaused) {
            console.log('[MOCK WS] Resuming simulation...');
            this.isPaused = false;
            
            // CHANGE: Removed `this.addStep(0, 'RUNNING')`
            // The next step in the pre-calculated timeline (start of n4) 
            // will automatically set the status to RUNNING.
            
            // Restart the loop immediately
            this.runLoop();
        }
    }

    send(data: any) {
        console.log('[MOCK WS] Received:', data);
    }

    close() {
        console.log('[MOCK WS] Closing connection');
        clearTimeout(this.timer);
        activeSocket = null;
        
        if (this.onclose) {
            this.onclose({ 
                code: 1000, 
                reason: 'Mock Simulation Ended', 
                wasClean: true 
            });
        }
    }

    private planSimulation() {
        // 1. Start State
        this.addStep(500, 'RUNNING');

        // 2. Orchestrator (n1) runs
        this.simulateAgentExecution('n1', 1500, 450);

        // 3. Parallel Execution: n2 (Dynamic) & n3 (Static)
        this.activeAgents.push('n2', 'n3');
        this.addStep(200);

        // Complete n3
        this.simulateAgentCompletion('n3', 2500, 800, false);

        // n2 does its dynamic delegation thing
        this.processDynamicChain('n2', 'n4'); 

        // === INSERT SYSTEM INTERVENTION HERE ===
        // We simulate a pause just before the final synthesis node (n4) starts.
        this.addStep(0, 'AWAITING_APPROVAL'); 
        // Note: The loop will PAUSE here until resume() is called.

        // 4. Synthesis (n4) runs (After approval)
        this.simulateAgentExecution('n4', 3000, 2500);

        // 5. Completion
        this.addStep(1000, 'COMPLETED');
    }

    private processDynamicChain(currentId: string, finalDependentId: string) {
        // Logic kept same as previous version...
        const isRoot = currentId === 'n2';
        const chance = isRoot ? 0.6 : 0.3;
        const shouldDelegate = Math.random() < chance;
        const depth = currentId.split('_').length;

        if (shouldDelegate && depth <= 3) {
            const newAgentId = `${currentId}_sub${Math.floor(Math.random() * 100)}`;
            const reason = isRoot ? "Topic too broad; spawning specialist." : "Additional verification.";

            const output = generateDelegationArtifact(reason, currentId, newAgentId);
            SESSION_ARTIFACTS[currentId] = { result: output };

            this.activeAgents = this.activeAgents.filter(id => id !== currentId);
            this.completedAgents.push(currentId);
            this.totalTokens += 500;
            
            this.invocations.push({
                id: `inv-${currentId}`,
                agent_id: currentId,
                status: 'success',
                tokens_used: 500,
                latency_ms: 1200,
                artifact_id: `mock-art-${currentId}`
            });

            this.topology.nodes.push(newAgentId);
            this.topology.edges.push({ from: currentId, to: newAgentId });
            this.topology.edges = this.topology.edges.filter(e => !(e.from === currentId && e.to === finalDependentId));
            this.topology.edges.push({ from: newAgentId, to: finalDependentId });

            this.signatures[currentId] = `hash_${currentId}`;
            this.addStep(1000); 

            this.activeAgents.push(newAgentId);
            this.addStep(500);

            this.processDynamicChain(newAgentId, finalDependentId);

        } else {
            SESSION_ARTIFACTS[currentId] = { 
                result: `Analysis complete for node ${currentId}. Validated 100% data points.` 
            };
            this.simulateAgentCompletion(currentId, 1500 + Math.random() * 1000, 600, true);
        }
    }

    private simulateAgentExecution(id: string, duration: number, tokens: number) {
        if (!this.activeAgents.includes(id)) {
            this.activeAgents.push(id);
        }
        this.addStep(200);
        this.simulateAgentCompletion(id, duration, tokens, false);
    }

    private simulateAgentCompletion(id: string, duration: number, tokens: number, isDynamic: boolean) {
        this.addStep(duration, undefined, () => {
            this.activeAgents = this.activeAgents.filter(a => a !== id);
            this.completedAgents.push(id);
            this.totalTokens += tokens;
            this.signatures[id] = `hash_${Math.floor(Math.random()*10000).toString(16)}`;
            
            this.invocations.push({
                id: `inv-${id}`,
                agent_id: id,
                status: 'success',
                tokens_used: tokens,
                latency_ms: duration,
                artifact_id: `mock-art-${id}`
            });
        });
    }

    private addStep(delay: number, statusOverride?: string, action?: () => void) {
        // Closure to capture state at execution time
        const stepAction = () => {
            if (action) action();
            // Snapshot logic...
        };

        // We push a 'thunk' that generates the snapshot when called,
        // or we push a config object and generate snapshot in runLoop.
        // For this procedural generation, we are building a timeline array upfront,
        // but the state needs to accumulate.
        
        // REFACTOR NOTE: To allow procedural state accumulation, we will execute the action
        // immediately during generation, but capture the *resultant* state into the step array.
        // This is strictly deterministic for the mock.
        if (action) action();

        const snapshot = {
            delay,
            state: {
                status: statusOverride || 'RUNNING',
                active_agents: [...this.activeAgents],
                completed_agents: [...this.completedAgents],
                failed_agents: [],
                total_tokens_used: this.totalTokens,
                invocations: JSON.parse(JSON.stringify(this.invocations)) // Deep copy
            },
            signatures: { ...this.signatures },
            topology: JSON.parse(JSON.stringify(this.topology))
        };

        this.steps.push(snapshot);
    }

    private runLoop() {
        if (this.currentStep >= this.steps.length) {
            this.close();
            return;
        }

        const step = this.steps[this.currentStep];
        
        // 1. Send the Update
        const message = {
            type: 'state_update',
            state: step.state,
            signatures: step.signatures || {},
            topology: step.topology || null
        };

        if (this.onmessage) {
            this.onmessage({ data: JSON.stringify(message) });
        }

        // 2. CHECK FOR INTERVENTION (PAUSE)
        if (step.state.status === 'AWAITING_APPROVAL') {
            console.log('[MOCK WS] Simulation paused for approval.');
            this.isPaused = true;
            this.currentStep++; // Ready for next step when resumed
            return; // EXIT LOOP - Do not set timer
        }

        // 3. Schedule next step
        this.timer = setTimeout(() => {
            this.currentStep++;
            this.runLoop();
        }, step.delay);
    }
}