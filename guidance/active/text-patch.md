Here are the recommended patches in order of importance.

---

### 1. CRITICAL: Fix Syntax Highlighting Collision
**The Issue:** In `syntax-lite.ts`, you are performing sequential string replacements.
1. Step 1 adds `<span class="token-str">`.
2. Step 3 highlights keywords. **`class`** is in your keyword list.
3. The regex for keywords matches the `class` attribute *inside* the HTML tags generated in Step 1.
4. Result: `<span <span class="token-kw">class</span>="token-str">`, which breaks the HTML.

**The Fix:** Use a placeholder strategy to protect HTML tags generated by previous steps.

**File:** `src/lib/syntax-lite.ts`

```typescript
// [[RARO]]/apps/web-console/src/lib/syntax-lite.ts

export function highlight(code: string, lang: string): string {
    // 1. Sanitize HTML entities first to prevent injection/layout breaking
    let html = code
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  
    // Storage for protected tokens (Strings & Comments)
    const tokens: string[] = [];
    const pushToken = (str: string) => {
        tokens.push(str);
        return `%%%TOKEN_${tokens.length - 1}%%%`;
    };
  
    // 2. Extract Strings (Single/Double/Backtick) -> Placeholders
    // We do this first so keywords/comments inside strings are ignored
    html = html.replace(/(['"`])(.*?)\1/g, (match) => {
        return pushToken(`<span class="token-str">${match}</span>`);
    });
  
    // 3. Extract Comments -> Placeholders
    // Note: JS/TS style // and Python/Bash style #
    html = html.replace(/(\/\/.*$)|(#.*$)/gm, (match) => {
        return pushToken(`<span class="token-comment">${match}</span>`);
    });
  
    // 4. Highlight Keywords (Safe to do now, strings/comments are hidden)
    const keywords = /\b(import|export|from|const|let|var|function|return|if|else|for|while|class|interface|type|async|await|def|print|impl|struct|fn|pub)\b/g;
    html = html.replace(keywords, '<span class="token-kw">$1</span>');
  
    // 5. Highlight Numbers
    html = html.replace(/\b(\d+)\b/g, '<span class="token-num">$1</span>');
  
    // 6. Highlight Booleans
    html = html.replace(/\b(true|false|null|None)\b/g, '<span class="token-bool">$1</span>');
  
    // 7. Restore Placeholders
    // We cycle until no placeholders remain (just in case)
    tokens.forEach((token, i) => {
        html = html.replace(`%%%TOKEN_${i}%%%`, token);
    });
  
    return html;
}
```

---

### 2. SECURITY & LAYOUT: Escape Text in Typewriter
**The Issue:** In `Typewriter.svelte`, you use `{@html segment.content...}` for text segments.
If an agent outputs: `"Use the <Button /> component"`, the browser will try to render `<Button />` as HTML. It will be invisible (treated as an unknown tag) or break the layout. It also opens a vector for XSS if the logs contain malicious scripts.

**The Fix:** Escape HTML entities in text segments *before* replacing newlines.

**File:** `src/components/sub/Typewriter.svelte`

1. Add a helper function to the `<script>` block:
```typescript
function escapeHtml(unsafe: string) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
```

2. Update the template HTML block:

```svelte
<!-- Inside the {#each segments...} loop, in the {:else} block -->
{:else}
  <!-- 
     1. Escape HTML (So "<Button>" shows as text, not a hidden tag) 
     2. Replace newlines with actual line breaks for pre-wrap
  -->
  <span class="text-body">{@html escapeHtml(segment.content).replace(/\\n/g, '\n')}</span>
  
  {#if isTyping && i === segments.length - 1}
     <span class="cursor" style:opacity={showCursor ? 1 : 0}>â–‹</span>
  {/if}
{/if}
```

---

### 3. ROBUSTNESS: Relaxed Artifact Parsing
**The Issue:** In `OutputPane.svelte` (and `mock-api.ts`), the regex expects a very specific format: `[SYSTEM: Generated Image saved to 'filename.png']`.
LLMs sometimes hallucinate extra spaces: `[ SYSTEM: Generated ... ]`. If the regex fails, the "ugly" system tag remains visible to the user, and the Artifact Card doesn't appear.

**The Fix:** Make the regex whitespace-agnostic.

**File:** `src/components/OutputPane.svelte`

Update the `systemRegex` in `extractAllFilenames` and `stripSystemTags`:

```typescript
// Allow optional spaces \s* around colons and brackets
const systemRegex = /\[\s*SYSTEM\s*:\s*Generated\s*(?:Image|File)\s*saved\s*to\s*'([^']+)'\s*\]/gi;
```

Updated `stripSystemTags` function:
```typescript
function stripSystemTags(msg: string): string {
    let cleaned = msg;
    
    // 1. Remove Markdown Images
    cleaned = cleaned.replace(/!\[.*?\]\(([^)]+\.(?:png|jpg|jpeg|svg|json|csv|txt))\)/gi, '');
    
    // 2. Remove RFS System Tags (Relaxed Regex)
    cleaned = cleaned.replace(/\[\s*SYSTEM\s*:\s*Generated\s*(?:Image|File)\s*saved\s*to\s*'[^']+'\s*\]/gi, '');
    
    return cleaned.trim();
}
```

### 4. VISUAL: Scroll Anchoring Polish
**The Issue:** In `OutputPane.svelte`, you are using `scrollTo` inside an effect. When streaming very fast, `scrollTo({ behavior: 'smooth' })` can sometimes lag behind the text generation, causing the "jittery scroll" effect where the user sees the text go off-screen and then snap back.

**The Fix:** Use `instant` (or `auto`) scrolling when "pinned" and receiving live updates, and only use `smooth` for the initial load or manual interactions.

**File:** `src/components/OutputPane.svelte`

```typescript
// In the effect tracking $logs
$effect(() => {
  const _l = $logs; 
  tick().then(() => {
    if (isPinnedToBottom) {
       // Use 'auto' (instant) instead of 'smooth' for live logs to prevent 
       // the viewport from lagging behind the Typewriter speed.
       scrollToBottom('auto'); 
    }
  });
});
```